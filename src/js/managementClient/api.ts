/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Pensieve API
 * Zenko server collector for metrics and configuration
 *
 * OpenAPI spec version: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost/api/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends window.Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AllStatsSeriesV1
 */
export interface AllStatsSeriesV1 {
    /**
     * 
     * @type {number}
     * @memberof AllStatsSeriesV1
     */
    intervalSeconds?: number;
    /**
     * 
     * @type {string}
     * @memberof AllStatsSeriesV1
     */
    startTime?: string;
    /**
     * 
     * @type {any}
     * @memberof AllStatsSeriesV1
     */
    stats?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof AllStatsSeriesV1
     */
    timestamps?: Array<string>;
}

/**
 * 
 * @export
 * @interface AllStatsUnitV1
 */
export interface AllStatsUnitV1 {
    /**
     * 
     * @type {InstanceCapabilitiesV1}
     * @memberof AllStatsUnitV1
     */
    capabilities?: InstanceCapabilitiesV1;
    /**
     * 
     * @type {CpuStatTimesUnitV1}
     * @memberof AllStatsUnitV1
     */
    cpu?: CpuStatTimesUnitV1;
    /**
     * 
     * @type {CrrScheduleV1}
     * @memberof AllStatsUnitV1
     */
    crrSchedule?: CrrScheduleV1;
    /**
     * 
     * @type {CrrStatsUnitV1}
     * @memberof AllStatsUnitV1
     */
    crrStats?: CrrStatsUnitV1;
    /**
     * 
     * @type {DataDiskUsageUnitV1}
     * @memberof AllStatsUnitV1
     */
    dataDiskUsage?: DataDiskUsageUnitV1;
    /**
     * 
     * @type {IngestionScheduleV1}
     * @memberof AllStatsUnitV1
     */
    ingestSchedule?: IngestionScheduleV1;
    /**
     * 
     * @type {IngestStatsUnitV1}
     * @memberof AllStatsUnitV1
     */
    ingestStats?: IngestStatsUnitV1;
    /**
     * 
     * @type {string}
     * @memberof AllStatsUnitV1
     */
    instanceId?: string;
    /**
     * 
     * @type {string}
     * @memberof AllStatsUnitV1
     */
    ipAddress?: string;
    /**
     * 
     * @type {ItemCountsUnitV1}
     * @memberof AllStatsUnitV1
     */
    itemCounts?: ItemCountsUnitV1;
    /**
     * 
     * @type {MdDiskUsageUnitV1}
     * @memberof AllStatsUnitV1
     */
    mdDiskUsage?: MdDiskUsageUnitV1;
    /**
     * 
     * @type {MemoryStatUnitV1}
     * @memberof AllStatsUnitV1
     */
    memory?: MemoryStatUnitV1;
    /**
     * 
     * @type {string}
     * @memberof AllStatsUnitV1
     */
    serverVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof AllStatsUnitV1
     */
    time?: string;
    /**
     * 
     * @type {number}
     * @memberof AllStatsUnitV1
     */
    ttl?: number;
}

/**
 * 
 * @export
 * @interface BrowserAccessConfigurationV1
 */
export interface BrowserAccessConfigurationV1 {
    /**
     * 
     * @type {boolean}
     * @memberof BrowserAccessConfigurationV1
     */
    enabled?: boolean;
}

/**
 * 
 * @export
 * @interface BucketInfoUnitV1
 */
export interface BucketInfoUnitV1 {
    /**
     * 
     * @type {boolean}
     * @memberof BucketInfoUnitV1
     */
    ingestion?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BucketInfoUnitV1
     */
    isVersioned?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BucketInfoUnitV1
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof BucketInfoUnitV1
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof BucketInfoUnitV1
     */
    ownerCanonicalId?: string;
}

/**
 * Lifecycle policy (single rule) to apply to a bucket
 * @export
 * @interface BucketWorkflowExpirationV1
 */
export interface BucketWorkflowExpirationV1 extends BucketWorkflowV1 {
    /**
     * 
     * @type {string}
     * @memberof BucketWorkflowExpirationV1
     */
    currentVersionTriggerDelayDate?: string;
    /**
     * 
     * @type {number}
     * @memberof BucketWorkflowExpirationV1
     */
    currentVersionTriggerDelayDays?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BucketWorkflowExpirationV1
     */
    expireDeleteMarkersTrigger?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BucketWorkflowExpirationV1
     */
    incompleteMultipartUploadTriggerDelayDays?: number;
    /**
     * 
     * @type {number}
     * @memberof BucketWorkflowExpirationV1
     */
    previousVersionTriggerDelayDays?: number;
}

/**
 * @export
 * @namespace BucketWorkflowExpirationV1
 */
export namespace BucketWorkflowExpirationV1 {
}

/**
 * Lifecycle transition policy (single rule) to apply to a bucket
 * @export
 * @interface BucketWorkflowTransitionV1
 */
export interface BucketWorkflowTransitionV1 extends BucketWorkflowV1 {
    /**
     * 
     * @type {string}
     * @memberof BucketWorkflowTransitionV1
     */
    locationName?: string;
    /**
     * 
     * @type {string}
     * @memberof BucketWorkflowTransitionV1
     */
    applyToVersions?: BucketWorkflowTransitionV1.ApplyToVersionsEnum;
    /**
     * 
     * @type {string}
     * @memberof BucketWorkflowTransitionV1
     */
    triggerDelayDate?: string;
    /**
     * 
     * @type {number}
     * @memberof BucketWorkflowTransitionV1
     */
    triggerDelayDays?: number;
}

/**
 * @export
 * @namespace BucketWorkflowTransitionV1
 */
export namespace BucketWorkflowTransitionV1 {
    /**
     * @export
     * @enum {string}
     */
    export enum ApplyToVersionsEnum {
        Current = <any> 'current',
        Previous = <any> 'previous'
    }
}

/**
 * Lifecycle transition policy (single rule) to apply to a bucket
 * @export
 * @interface BucketWorkflowTransitionV2
 */
export interface BucketWorkflowTransitionV2 extends BucketWorkflowV1 {
    /**
     * 
     * @type {string}
     * @memberof BucketWorkflowTransitionV2
     */
    applyToVersion: BucketWorkflowTransitionV2.ApplyToVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof BucketWorkflowTransitionV2
     */
    locationName: string;
    /**
     * 
     * @type {string}
     * @memberof BucketWorkflowTransitionV2
     */
    triggerDelayDate?: string;
    /**
     * 
     * @type {number}
     * @memberof BucketWorkflowTransitionV2
     */
    triggerDelayDays?: number;
}

/**
 * @export
 * @namespace BucketWorkflowTransitionV2
 */
export namespace BucketWorkflowTransitionV2 {
    /**
     * @export
     * @enum {string}
     */
    export enum ApplyToVersionEnum {
        Current = <any> 'current',
        Noncurrent = <any> 'noncurrent'
    }
}

/**
 * Workflow to apply to a bucket
 * @export
 * @interface BucketWorkflowV1
 */
export interface BucketWorkflowV1 {
    /**
     * 
     * @type {string}
     * @memberof BucketWorkflowV1
     */
    bucketName: string;
    /**
     * 
     * @type {boolean}
     * @memberof BucketWorkflowV1
     */
    enabled: boolean;
    /**
     * 
     * @type {any}
     * @memberof BucketWorkflowV1
     */
    filter?: any;
    /**
     * 
     * @type {string}
     * @memberof BucketWorkflowV1
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof BucketWorkflowV1
     */
    type: BucketWorkflowV1.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BucketWorkflowV1
     */
    workflowId?: string;
}

/**
 * @export
 * @namespace BucketWorkflowV1
 */
export namespace BucketWorkflowV1 {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        ExpirationV1 = <any> 'bucket-workflow-expiration-v1',
        TransitionV1 = <any> 'bucket-workflow-transition-v1',
        TransitionV2 = <any> 'bucket-workflow-transition-v2',
        ReplicationV1 = <any> 'bucket-workflow-replication-v1'
    }
}

/**
 * 
 * @export
 * @interface ConfigOverlayV1
 */
export interface ConfigOverlayV1 {
    /**
     * 
     * @type {BrowserAccessConfigurationV1}
     * @memberof ConfigOverlayV1
     */
    browserAccess: BrowserAccessConfigurationV1;
    /**
     * 
     * @type {string}
     * @memberof ConfigOverlayV1
     */
    creator?: string;
    /**
     * 
     * @type {Array<EndpointV1>}
     * @memberof ConfigOverlayV1
     */
    endpoints?: Array<EndpointV1>;
    /**
     * 
     * @type {string}
     * @memberof ConfigOverlayV1
     */
    instanceId?: string;
    /**
     * 
     * @type {{ [key: string]: LocationV1; }}
     * @memberof ConfigOverlayV1
     */
    locations?: { [key: string]: LocationV1; };
    /**
     * 
     * @type {Array<ReplicationStreamInternalV1>}
     * @memberof ConfigOverlayV1
     */
    replicationStreams?: Array<ReplicationStreamInternalV1>;
    /**
     * 
     * @type {string}
     * @memberof ConfigOverlayV1
     */
    updatedAt?: string;
    /**
     * 
     * @type {Array<UserV1>}
     * @memberof ConfigOverlayV1
     */
    users?: Array<UserV1>;
    /**
     * 
     * @type {number}
     * @memberof ConfigOverlayV1
     */
    version?: number;
    /**
     * 
     * @type {any}
     * @memberof ConfigOverlayV1
     */
    workflows?: any;
}

/**
 * 
 * @export
 * @interface CounterUnitV1
 */
export interface CounterUnitV1 {
    /**
     * 
     * @type {number}
     * @memberof CounterUnitV1
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof CounterUnitV1
     */
    size?: number;
}

/**
 * 
 * @export
 * @interface CpuStatSeriesV1
 */
export interface CpuStatSeriesV1 extends Array<number> {
}

/**
 * 
 * @export
 * @interface CpuStatTimesUnitV1
 */
export interface CpuStatTimesUnitV1 {
    /**
     * 
     * @type {number}
     * @memberof CpuStatTimesUnitV1
     */
    idle: number;
    /**
     * 
     * @type {number}
     * @memberof CpuStatTimesUnitV1
     */
    nice: number;
    /**
     * 
     * @type {number}
     * @memberof CpuStatTimesUnitV1
     */
    sys: number;
    /**
     * 
     * @type {number}
     * @memberof CpuStatTimesUnitV1
     */
    user: number;
}

/**
 * 
 * @export
 * @interface CrrScheduleV1
 */
export interface CrrScheduleV1 {
}

/**
 * 
 * @export
 * @interface CrrStatSeriesV1
 */
export interface CrrStatSeriesV1 {
    /**
     * 
     * @type {Array<CounterUnitV1>}
     * @memberof CrrStatSeriesV1
     */
    backlog?: Array<CounterUnitV1>;
    /**
     * 
     * @type {Array<CounterUnitV1>}
     * @memberof CrrStatSeriesV1
     */
    completions?: Array<CounterUnitV1>;
    /**
     * 
     * @type {Array<CounterUnitV1>}
     * @memberof CrrStatSeriesV1
     */
    pending?: Array<CounterUnitV1>;
    /**
     * 
     * @type {Array<CounterUnitV1>}
     * @memberof CrrStatSeriesV1
     */
    stalled?: Array<CounterUnitV1>;
    /**
     * 
     * @type {Array<CounterUnitV1>}
     * @memberof CrrStatSeriesV1
     */
    throughput?: Array<CounterUnitV1>;
}

/**
 * 
 * @export
 * @interface CrrStatsUnitV1
 */
export interface CrrStatsUnitV1 extends WorkflowStatsUnitV1 {
}

/**
 * 
 * @export
 * @interface DataDiskUsageUnitV1
 */
export interface DataDiskUsageUnitV1 extends DiskUsageUnitV1 {
}

/**
 * 
 * @export
 * @interface DataManagedGroupedV1
 */
export interface DataManagedGroupedV1 {
    /**
     * 
     * @type {{ [key: string]: DataManagedUnitV1; }}
     * @memberof DataManagedGroupedV1
     */
    byLocation?: { [key: string]: DataManagedUnitV1; };
    /**
     * 
     * @type {DataManagedUnitV1}
     * @memberof DataManagedGroupedV1
     */
    total?: DataManagedUnitV1;
}

/**
 * 
 * @export
 * @interface DataManagedUnitV1
 */
export interface DataManagedUnitV1 {
    /**
     * 
     * @type {number}
     * @memberof DataManagedUnitV1
     */
    curr?: number;
    /**
     * 
     * @type {number}
     * @memberof DataManagedUnitV1
     */
    prev?: number;
}

/**
 * 
 * @export
 * @interface DiskUsageUnitV1
 */
export interface DiskUsageUnitV1 {
    /**
     * 
     * @type {number}
     * @memberof DiskUsageUnitV1
     */
    available: number;
    /**
     * 
     * @type {number}
     * @memberof DiskUsageUnitV1
     */
    free: number;
    /**
     * 
     * @type {number}
     * @memberof DiskUsageUnitV1
     */
    total: number;
}

/**
 * 
 * @export
 * @interface DiskusageStatSeriesV1
 */
export interface DiskusageStatSeriesV1 {
    /**
     * 
     * @type {Array<number>}
     * @memberof DiskusageStatSeriesV1
     */
    available?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DiskusageStatSeriesV1
     */
    free?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DiskusageStatSeriesV1
     */
    total?: Array<number>;
}

/**
 * 
 * @export
 * @interface EndpointV1
 */
export interface EndpointV1 {
    /**
     * 
     * @type {string}
     * @memberof EndpointV1
     */
    hostname: string;
    /**
     * 
     * @type {boolean}
     * @memberof EndpointV1
     */
    isBuiltin?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EndpointV1
     */
    locationName: string;
}

/**
 * 
 * @export
 * @interface Error
 */
export interface Error {
    /**
     * 
     * @type {number}
     * @memberof Error
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof Error
     */
    errorType?: Error.ErrorTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Error
     */
    fieldName?: string;
    /**
     * 
     * @type {string}
     * @memberof Error
     */
    message?: string;
}

/**
 * @export
 * @namespace Error
 */
export namespace Error {
    /**
     * @export
     * @enum {string}
     */
    export enum ErrorTypeEnum {
        ValidatorError = <any> 'ValidatorError',
        VersioningNotEnabled = <any> 'VersioningNotEnabled',
        BadCredentials = <any> 'BadCredentials',
        InvalidAccessKey = <any> 'InvalidAccessKey',
        InvalidSecretKey = <any> 'InvalidSecretKey',
        AccessDenied = <any> 'AccessDenied',
        TargetBucketNotFound = <any> 'TargetBucketNotFound',
        InvalidEndpoint = <any> 'InvalidEndpoint',
        InvalidBucketName = <any> 'InvalidBucketName',
        InvalidEntityUpdate = <any> 'InvalidEntityUpdate'
    }
}

/**
 * 
 * @export
 * @interface IngestStatsUnitV1
 */
export interface IngestStatsUnitV1 extends WorkflowStatsUnitV1 {
}

/**
 * 
 * @export
 * @interface IngestionScheduleV1
 */
export interface IngestionScheduleV1 {
}

/**
 * 
 * @export
 * @interface InstanceAclsV1
 */
export interface InstanceAclsV1 {
    /**
     * 
     * @type {string}
     * @memberof InstanceAclsV1
     */
    instanceID?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceAclsV1
     */
    principalID?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceAclsV1
     */
    principalType?: InstanceAclsV1.PrincipalTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InstanceAclsV1
     */
    role?: InstanceAclsV1.RoleEnum;
    /**
     * 
     * @type {string}
     * @memberof InstanceAclsV1
     */
    scope?: InstanceAclsV1.ScopeEnum;
}

/**
 * @export
 * @namespace InstanceAclsV1
 */
export namespace InstanceAclsV1 {
    /**
     * @export
     * @enum {string}
     */
    export enum PrincipalTypeEnum {
        User = <any> 'user',
        Group = <any> 'group'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        Owner = <any> 'owner',
        Viewer = <any> 'viewer',
        Editor = <any> 'editor'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ScopeEnum {
        All = <any> 'all',
        Secrets = <any> 'secrets',
        Configuration = <any> 'configuration',
        Metrics = <any> 'metrics',
        Logs = <any> 'logs',
        Operations = <any> 'operations'
    }
}

/**
 * 
 * @export
 * @interface InstanceCapabilitiesV1
 */
export interface InstanceCapabilitiesV1 {
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    awsIngestLocation?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    cephIngestLocation?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    locationTypeCephRadosGW?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    locationTypeDigitalOcean?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    locationTypeHyperdriveV2?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    locationTypeLocal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    locationTypeNFS?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    locationTypeS3Custom?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    locationTypeSproxyd?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    managedLifecycle?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    managedLifecycleTransition?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    nfsIngestLocation?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    preferredReadLocation?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    s3cIngestLocation?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    secureChannel?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceCapabilitiesV1
     */
    secureChannelOptimizedPath?: boolean;
}

/**
 * 
 * @export
 * @interface InstanceConfirmationDataV1
 */
export interface InstanceConfirmationDataV1 {
    /**
     * 
     * @type {string}
     * @memberof InstanceConfirmationDataV1
     */
    publicKey: string;
    /**
     * 
     * @type {number}
     * @memberof InstanceConfirmationDataV1
     */
    serial: number;
}

/**
 * 
 * @export
 * @interface InstanceCredentialsV1
 */
export interface InstanceCredentialsV1 {
    /**
     * 
     * @type {string}
     * @memberof InstanceCredentialsV1
     */
    instanceId?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceCredentialsV1
     */
    issueDate?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceCredentialsV1
     */
    publicKey?: string;
    /**
     * 
     * @type {number}
     * @memberof InstanceCredentialsV1
     */
    serial?: number;
    /**
     * 
     * @type {string}
     * @memberof InstanceCredentialsV1
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface InstanceMetricsUnitV1
 */
export interface InstanceMetricsUnitV1 {
    /**
     * 
     * @type {CpuStatTimesUnitV1}
     * @memberof InstanceMetricsUnitV1
     */
    cpu?: CpuStatTimesUnitV1;
    /**
     * 
     * @type {CrrScheduleV1}
     * @memberof InstanceMetricsUnitV1
     */
    crrSchedule?: CrrScheduleV1;
    /**
     * 
     * @type {CrrStatsUnitV1}
     * @memberof InstanceMetricsUnitV1
     */
    crrStats?: CrrStatsUnitV1;
    /**
     * 
     * @type {DataDiskUsageUnitV1}
     * @memberof InstanceMetricsUnitV1
     */
    dataDiskUsage?: DataDiskUsageUnitV1;
    /**
     * 
     * @type {IngestionScheduleV1}
     * @memberof InstanceMetricsUnitV1
     */
    ingestSchedule?: IngestionScheduleV1;
    /**
     * 
     * @type {IngestStatsUnitV1}
     * @memberof InstanceMetricsUnitV1
     */
    ingestStats?: IngestStatsUnitV1;
    /**
     * 
     * @type {ItemCountsUnitV1}
     * @memberof InstanceMetricsUnitV1
     */
    itemCounts?: ItemCountsUnitV1;
    /**
     * 
     * @type {MdDiskUsageUnitV1}
     * @memberof InstanceMetricsUnitV1
     */
    mdDiskUsage?: MdDiskUsageUnitV1;
    /**
     * 
     * @type {MemoryStatUnitV1}
     * @memberof InstanceMetricsUnitV1
     */
    memory?: MemoryStatUnitV1;
}

/**
 * 
 * @export
 * @interface InstanceRegisterDataV1
 */
export interface InstanceRegisterDataV1 {
    /**
     * 
     * @type {string}
     * @memberof InstanceRegisterDataV1
     */
    publicKey: string;
}

/**
 * 
 * @export
 * @interface InstanceRegistryV1
 */
export interface InstanceRegistryV1 {
    /**
     * 
     * @type {string}
     * @memberof InstanceRegistryV1
     */
    instanceID?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceRegistryV1
     */
    lastSeen?: string;
}

/**
 * 
 * @export
 * @interface InstanceStatusDataV1
 */
export interface InstanceStatusDataV1 {
    /**
     * 
     * @type {InstanceCapabilitiesV1}
     * @memberof InstanceStatusDataV1
     */
    capabilities?: InstanceCapabilitiesV1;
    /**
     * 
     * @type {string}
     * @memberof InstanceStatusDataV1
     */
    ipAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceStatusDataV1
     */
    lastSeen?: string;
    /**
     * 
     * @type {ConfigOverlayV1}
     * @memberof InstanceStatusDataV1
     */
    latestConfigurationOverlay?: ConfigOverlayV1;
    /**
     * 
     * @type {number}
     * @memberof InstanceStatusDataV1
     */
    runningConfigurationVersion?: number;
    /**
     * 
     * @type {string}
     * @memberof InstanceStatusDataV1
     */
    serverVersion?: string;
}

/**
 * 
 * @export
 * @interface InstanceV1
 */
export interface InstanceV1 {
    /**
     * 
     * @type {string}
     * @memberof InstanceV1
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceV1
     */
    friendlyName?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceV1
     */
    instanceId?: string;
    /**
     * 
     * @type {OrganizationV1}
     * @memberof InstanceV1
     */
    organization?: OrganizationV1;
    /**
     * 
     * @type {string}
     * @memberof InstanceV1
     */
    organizationID?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceV1
     */
    owner?: string;
    /**
     * 
     * @type {any}
     * @memberof InstanceV1
     */
    provisioning?: any;
    /**
     * 
     * @type {string}
     * @memberof InstanceV1
     */
    publicKey?: string;
    /**
     * 
     * @type {number}
     * @memberof InstanceV1
     */
    publicKeyVersion?: number;
    /**
     * 
     * @type {string}
     * @memberof InstanceV1
     */
    state?: InstanceV1.StateEnum;
}

/**
 * @export
 * @namespace InstanceV1
 */
export namespace InstanceV1 {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Provisioning = <any> 'provisioning',
        New = <any> 'new',
        Confirmed = <any> 'confirmed'
    }
}

/**
 * 
 * @export
 * @interface ItemCountsSeriesV1
 */
export interface ItemCountsSeriesV1 {
    /**
     * 
     * @type {Array<BucketInfoUnitV1>}
     * @memberof ItemCountsSeriesV1
     */
    bucketList?: Array<BucketInfoUnitV1>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ItemCountsSeriesV1
     */
    buckets?: Array<number>;
    /**
     * 
     * @type {Array<DataManagedGroupedV1>}
     * @memberof ItemCountsSeriesV1
     */
    dataManaged?: Array<DataManagedGroupedV1>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ItemCountsSeriesV1
     */
    objects?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ItemCountsSeriesV1
     */
    versions?: Array<number>;
}

/**
 * 
 * @export
 * @interface ItemCountsUnitV1
 */
export interface ItemCountsUnitV1 {
    /**
     * 
     * @type {Array<BucketInfoUnitV1>}
     * @memberof ItemCountsUnitV1
     */
    bucketList?: Array<BucketInfoUnitV1>;
    /**
     * 
     * @type {number}
     * @memberof ItemCountsUnitV1
     */
    buckets: number;
    /**
     * 
     * @type {DataManagedGroupedV1}
     * @memberof ItemCountsUnitV1
     */
    dataManaged?: DataManagedGroupedV1;
    /**
     * 
     * @type {number}
     * @memberof ItemCountsUnitV1
     */
    objects: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCountsUnitV1
     */
    versions: number;
}

/**
 * 
 * @export
 * @interface LocationAwsS3V1
 */
export interface LocationAwsS3V1 extends LocationV1 {
}

/**
 * @export
 * @namespace LocationAwsS3V1
 */
export namespace LocationAwsS3V1 {
}

/**
 * 
 * @export
 * @interface LocationAzureV1
 */
export interface LocationAzureV1 extends LocationV1 {
}

/**
 * @export
 * @namespace LocationAzureV1
 */
export namespace LocationAzureV1 {
}

/**
 * 
 * @export
 * @interface LocationDmfV1
 */
export interface LocationDmfV1 extends LocationV1 {
}

/**
 * @export
 * @namespace LocationDmfV1
 */
export namespace LocationDmfV1 {
}

/**
 * 
 * @export
 * @interface LocationFileV1
 */
export interface LocationFileV1 extends LocationV1 {
}

/**
 * @export
 * @namespace LocationFileV1
 */
export namespace LocationFileV1 {
}

/**
 * 
 * @export
 * @interface LocationMemV1
 */
export interface LocationMemV1 extends LocationV1 {
}

/**
 * @export
 * @namespace LocationMemV1
 */
export namespace LocationMemV1 {
}

/**
 * 
 * @export
 * @interface LocationV1
 */
export interface LocationV1 {
    /**
     * 
     * @type {any}
     * @memberof LocationV1
     */
    details?: any;
    /**
     * 
     * @type {number}
     * @memberof LocationV1
     */
    encryptionKeyVersion?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LocationV1
     */
    isBuiltin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LocationV1
     */
    isCold?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LocationV1
     */
    isTransient?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LocationV1
     */
    legacyAwsBehavior?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LocationV1
     */
    locationType: LocationV1.LocationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof LocationV1
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof LocationV1
     */
    objectId?: string;
    /**
     * 
     * @type {number}
     * @memberof LocationV1
     */
    sizeLimitGB?: number;
}

/**
 * @export
 * @namespace LocationV1
 */
export namespace LocationV1 {
    /**
     * @export
     * @enum {string}
     */
    export enum LocationTypeEnum {
        MemV1 = <any> 'location-mem-v1',
        FileV1 = <any> 'location-file-v1',
        AzureV1 = <any> 'location-azure-v1',
        AwsS3V1 = <any> 'location-aws-s3-v1',
        GcpV1 = <any> 'location-gcp-v1',
        B2V1 = <any> 'location-b2-v1',
        WasabiV1 = <any> 'location-wasabi-v1',
        DoSpacesV1 = <any> 'location-do-spaces-v1',
        ScalityRingS3V1 = <any> 'location-scality-ring-s3-v1',
        ScalityArtescaS3V1 = <any> 'location-scality-artesca-s3-v1',
        ScalitySproxydV1 = <any> 'location-scality-sproxyd-v1',
        ScalityHdclientV1 = <any> 'location-scality-hdclient-v1',
        ScalityHdclientV2 = <any> 'location-scality-hdclient-v2',
        CephRadosgwS3V1 = <any> 'location-ceph-radosgw-s3-v1',
        NfsMountV1 = <any> 'location-nfs-mount-v1',
        DmfV1 = <any> 'location-dmf-v1'
    }
}

/**
 * 
 * @export
 * @interface MdDiskUsageUnitV1
 */
export interface MdDiskUsageUnitV1 extends DiskUsageUnitV1 {
}

/**
 * 
 * @export
 * @interface MemoryStatSeriesV1
 */
export interface MemoryStatSeriesV1 {
    /**
     * 
     * @type {Array<number>}
     * @memberof MemoryStatSeriesV1
     */
    free?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof MemoryStatSeriesV1
     */
    total?: Array<number>;
}

/**
 * 
 * @export
 * @interface MemoryStatUnitV1
 */
export interface MemoryStatUnitV1 {
    /**
     * 
     * @type {number}
     * @memberof MemoryStatUnitV1
     */
    free: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryStatUnitV1
     */
    total: number;
}

/**
 * 
 * @export
 * @interface OrbitUserInviteStatusV1
 */
export interface OrbitUserInviteStatusV1 {
    /**
     * 
     * @type {boolean}
     * @memberof OrbitUserInviteStatusV1
     */
    closed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrbitUserInviteStatusV1
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof OrbitUserInviteStatusV1
     */
    date?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrbitUserInviteStatusV1
     */
    invited?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrbitUserInviteStatusV1
     */
    inviteeEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof OrbitUserInviteStatusV1
     */
    inviteeName?: string;
    /**
     * 
     * @type {string}
     * @memberof OrbitUserInviteStatusV1
     */
    inviterEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof OrbitUserInviteStatusV1
     */
    inviterName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrbitUserInviteStatusV1
     */
    responded?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrbitUserInviteStatusV1
     */
    userId?: string;
}

/**
 * 
 * @export
 * @interface OrganizationMembershipV1
 */
export interface OrganizationMembershipV1 {
    /**
     * 
     * @type {string}
     * @memberof OrganizationMembershipV1
     */
    organizationID?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMembershipV1
     */
    userID?: string;
}

/**
 * 
 * @export
 * @interface OrganizationV1
 */
export interface OrganizationV1 {
    /**
     * 
     * @type {string}
     * @memberof OrganizationV1
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationV1
     */
    organizationID?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationV1
     */
    owner?: string;
    /**
     * 
     * @type {any}
     * @memberof OrganizationV1
     */
    settings?: any;
}

/**
 * 
 * @export
 * @interface OutCpuStatsV1
 */
export interface OutCpuStatsV1 {
    /**
     * 
     * @type {number}
     * @memberof OutCpuStatsV1
     */
    intervalSeconds?: number;
    /**
     * 
     * @type {string}
     * @memberof OutCpuStatsV1
     */
    startTime?: string;
    /**
     * 
     * @type {any}
     * @memberof OutCpuStatsV1
     */
    values?: any;
}

/**
 * 
 * @export
 * @interface OutDataDiskStatsV1
 */
export interface OutDataDiskStatsV1 {
    /**
     * 
     * @type {number}
     * @memberof OutDataDiskStatsV1
     */
    intervalSeconds?: number;
    /**
     * 
     * @type {string}
     * @memberof OutDataDiskStatsV1
     */
    startTime?: string;
    /**
     * 
     * @type {any}
     * @memberof OutDataDiskStatsV1
     */
    values?: any;
}

/**
 * 
 * @export
 * @interface OutMdDiskStatsV1
 */
export interface OutMdDiskStatsV1 {
    /**
     * 
     * @type {number}
     * @memberof OutMdDiskStatsV1
     */
    intervalSeconds?: number;
    /**
     * 
     * @type {string}
     * @memberof OutMdDiskStatsV1
     */
    startTime?: string;
    /**
     * 
     * @type {any}
     * @memberof OutMdDiskStatsV1
     */
    values?: any;
}

/**
 * 
 * @export
 * @interface OutMemoryStatsV1
 */
export interface OutMemoryStatsV1 {
    /**
     * 
     * @type {number}
     * @memberof OutMemoryStatsV1
     */
    intervalSeconds?: number;
    /**
     * 
     * @type {string}
     * @memberof OutMemoryStatsV1
     */
    startTime?: string;
    /**
     * 
     * @type {any}
     * @memberof OutMemoryStatsV1
     */
    values?: any;
}

/**
 * 
 * @export
 * @interface PortalUserPreferencesV1
 */
export interface PortalUserPreferencesV1 {
    /**
     * 
     * @type {any}
     * @memberof PortalUserPreferencesV1
     */
    consent?: any;
}

/**
 * 
 * @export
 * @interface PortalUserV1
 */
export interface PortalUserV1 {
    /**
     * 
     * @type {string}
     * @memberof PortalUserV1
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof PortalUserV1
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof PortalUserV1
     */
    email: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof PortalUserV1
     */
    identities?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof PortalUserV1
     */
    identityProvider?: PortalUserV1.IdentityProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof PortalUserV1
     */
    imageUrl: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PortalUserV1
     */
    instanceIds: Array<string>;
    /**
     * 
     * @type {Array<InstanceV1>}
     * @memberof PortalUserV1
     */
    instances?: Array<InstanceV1>;
    /**
     * 
     * @type {string}
     * @memberof PortalUserV1
     */
    inviteCode?: string;
    /**
     * 
     * @type {string}
     * @memberof PortalUserV1
     */
    oidcSubject?: string;
    /**
     * 
     * @type {PortalUserPreferencesV1}
     * @memberof PortalUserV1
     */
    preferences?: PortalUserPreferencesV1;
    /**
     * 
     * @type {string}
     * @memberof PortalUserV1
     */
    updatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof PortalUserV1
     */
    userId?: string;
}

/**
 * @export
 * @namespace PortalUserV1
 */
export namespace PortalUserV1 {
    /**
     * @export
     * @enum {string}
     */
    export enum IdentityProviderEnum {
        Google = <any> 'google',
        Oidc = <any> 'oidc'
    }
}

/**
 * Replication between two buckets of the same Zenko instance
 * @export
 * @interface ReplicationStreamInternalV1
 */
export interface ReplicationStreamInternalV1 {
    /**
     * 
     * @type {any}
     * @memberof ReplicationStreamInternalV1
     */
    destination?: any;
    /**
     * 
     * @type {boolean}
     * @memberof ReplicationStreamInternalV1
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof ReplicationStreamInternalV1
     */
    name: string;
    /**
     * 
     * @type {any}
     * @memberof ReplicationStreamInternalV1
     */
    source?: any;
    /**
     * 
     * @type {string}
     * @memberof ReplicationStreamInternalV1
     */
    streamId?: string;
    /**
     * 
     * @type {number}
     * @memberof ReplicationStreamInternalV1
     */
    version: number;
}

/**
 * 
 * @export
 * @interface ReportV1
 */
export interface ReportV1 {
    /**
     * 
     * @type {InstanceCapabilitiesV1}
     * @memberof ReportV1
     */
    capabilities?: InstanceCapabilitiesV1;
    /**
     * 
     * @type {StoredConfigurationV1}
     * @memberof ReportV1
     */
    config: StoredConfigurationV1;
    /**
     * 
     * @type {CrrStatsUnitV1}
     * @memberof ReportV1
     */
    crrStats?: CrrStatsUnitV1;
    /**
     * 
     * @type {DataDiskUsageUnitV1}
     * @memberof ReportV1
     */
    dataDiskUsage: DataDiskUsageUnitV1;
    /**
     * 
     * @type {IngestStatsUnitV1}
     * @memberof ReportV1
     */
    ingestStats?: IngestStatsUnitV1;
    /**
     * 
     * @type {IngestionScheduleV1}
     * @memberof ReportV1
     */
    ingestStatus?: IngestionScheduleV1;
    /**
     * 
     * @type {string}
     * @memberof ReportV1
     */
    ipAddress?: string;
    /**
     * 
     * @type {ItemCountsUnitV1}
     * @memberof ReportV1
     */
    itemCounts: ItemCountsUnitV1;
    /**
     * 
     * @type {MdDiskUsageUnitV1}
     * @memberof ReportV1
     */
    mdDiskUsage: MdDiskUsageUnitV1;
    /**
     * 
     * @type {CrrScheduleV1}
     * @memberof ReportV1
     */
    repStatus?: CrrScheduleV1;
    /**
     * 
     * @type {number}
     * @memberof ReportV1
     */
    reportModelVersion: number;
    /**
     * 
     * @type {string}
     * @memberof ReportV1
     */
    serverVersion: string;
    /**
     * 
     * @type {SystemStatsUnitV1}
     * @memberof ReportV1
     */
    systemStats: SystemStatsUnitV1;
    /**
     * 
     * @type {string}
     * @memberof ReportV1
     */
    utcTime: string;
    /**
     * 
     * @type {string}
     * @memberof ReportV1
     */
    uuid: string;
}

/**
 * 
 * @export
 * @interface ScheduleV1
 */
export interface ScheduleV1 {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ScheduleV1
     */
    schedules?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ScheduleV1
     */
    states?: { [key: string]: string; };
}

/**
 * @export
 * @namespace ScheduleV1
 */
export namespace ScheduleV1 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatesEnum {
        Enabled = <any> 'enabled',
        Disabled = <any> 'disabled'
    }
}

/**
 * Search Workflow List
 * @export
 * @interface SearchWorkflowsListV1
 */
export interface SearchWorkflowsListV1 extends Array<any> {
}

/**
 * 
 * @export
 * @interface StoredConfigurationV1
 */
export interface StoredConfigurationV1 {
    /**
     * 
     * @type {string}
     * @memberof StoredConfigurationV1
     */
    instanceId?: string;
    /**
     * 
     * @type {number}
     * @memberof StoredConfigurationV1
     */
    overlayVersion?: number;
    /**
     * 
     * @type {string}
     * @memberof StoredConfigurationV1
     */
    time?: string;
    /**
     * 
     * @type {number}
     * @memberof StoredConfigurationV1
     */
    ttl?: number;
}

/**
 * 
 * @export
 * @interface SystemStatsUnitV1
 */
export interface SystemStatsUnitV1 {
    /**
     * 
     * @type {string}
     * @memberof SystemStatsUnitV1
     */
    arch: string;
    /**
     * 
     * @type {any}
     * @memberof SystemStatsUnitV1
     */
    cpu: any;
    /**
     * 
     * @type {string}
     * @memberof SystemStatsUnitV1
     */
    hostname: string;
    /**
     * 
     * @type {MemoryStatUnitV1}
     * @memberof SystemStatsUnitV1
     */
    memory: MemoryStatUnitV1;
    /**
     * 
     * @type {string}
     * @memberof SystemStatsUnitV1
     */
    platform: string;
    /**
     * 
     * @type {string}
     * @memberof SystemStatsUnitV1
     */
    release: string;
}

/**
 * 
 * @export
 * @interface UserV1
 */
export interface UserV1 {
    /**
     * 
     * @type {string}
     * @memberof UserV1
     */
    accessKey?: string;
    /**
     * 
     * @type {string}
     * @memberof UserV1
     */
    accountType?: UserV1.AccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserV1
     */
    arn?: string;
    /**
     * 
     * @type {string}
     * @memberof UserV1
     */
    canonicalId?: string;
    /**
     * 
     * @type {Date}
     * @memberof UserV1
     */
    createDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof UserV1
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserV1
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserV1
     */
    isBuiltin?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserV1
     */
    quotaMax?: number;
    /**
     * 
     * @type {string}
     * @memberof UserV1
     */
    secretKey?: string;
    /**
     * 
     * @type {number}
     * @memberof UserV1
     */
    secretKeyEncryptionKeyVersion?: number;
    /**
     * 
     * @type {string}
     * @memberof UserV1
     */
    userName: string;
}

/**
 * @export
 * @namespace UserV1
 */
export namespace UserV1 {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountTypeEnum {
        ServiceReplication = <any> 'service-replication',
        ServiceClueso = <any> 'service-clueso',
        ServiceLifecycle = <any> 'service-lifecycle',
        ServiceGc = <any> 'service-gc',
        ServiceMdIngestion = <any> 'service-md-ingestion',
        ServiceWorkflowEngine = <any> 'service-workflow-engine',
        StorageApi = <any> 'storage-api'
    }
}

/**
 * 
 * @export
 * @interface WorkflowCounterSetV1
 */
export interface WorkflowCounterSetV1 {
    /**
     * 
     * @type {CounterUnitV1}
     * @memberof WorkflowCounterSetV1
     */
    backlog?: CounterUnitV1;
    /**
     * 
     * @type {CounterUnitV1}
     * @memberof WorkflowCounterSetV1
     */
    completions?: CounterUnitV1;
    /**
     * 
     * @type {CounterUnitV1}
     * @memberof WorkflowCounterSetV1
     */
    failures?: CounterUnitV1;
    /**
     * 
     * @type {CounterUnitV1}
     * @memberof WorkflowCounterSetV1
     */
    pending?: CounterUnitV1;
    /**
     * 
     * @type {CounterUnitV1}
     * @memberof WorkflowCounterSetV1
     */
    stalled?: CounterUnitV1;
    /**
     * 
     * @type {CounterUnitV1}
     * @memberof WorkflowCounterSetV1
     */
    throughput?: CounterUnitV1;
}

/**
 * 
 * @export
 * @interface WorkflowStatsUnitV1
 */
export interface WorkflowStatsUnitV1 extends WorkflowCounterSetV1 {
    /**
     * 
     * @type {{ [key: string]: WorkflowCounterSetV1; }}
     * @memberof WorkflowStatsUnitV1
     */
    byLocation?: { [key: string]: WorkflowCounterSetV1; };
}


/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options: any = {}): FetchArgs {
            const localVarPath = `/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getHealth(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: any) {
            return DefaultApiFp(configuration).getHealth(options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Get health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHealth(options?: any) {
        return DefaultApiFp(this.configuration).getHealth(options)(this.fetch, this.basePath);
    }

}

/**
 * ManagedInstanceApi - fetch parameter creator
 * @export
 */
export const ManagedInstanceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Server-managed configuration values for use by managed instances
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceConfigurationOverlay(uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getInstanceConfigurationOverlay.');
            }
            const localVarPath = `/instance/{uuid}/config/overlay`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication managed-instance-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Instance-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Instance-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirms the instance to indicate that tokens and keys are safely stored
         * @param {string} uuid 
         * @param {InstanceConfirmationDataV1} confirmation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerInstanceConfirm(uuid: string, confirmation: InstanceConfirmationDataV1, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling registerInstanceConfirm.');
            }
            // verify required parameter 'confirmation' is not null or undefined
            if (confirmation === null || confirmation === undefined) {
                throw new RequiredError('confirmation','Required parameter confirmation was null or undefined when calling registerInstanceConfirm.');
            }
            const localVarPath = `/instance/{uuid}/confirm`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication managed-instance-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Instance-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Instance-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InstanceConfirmationDataV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(confirmation || {}) : (confirmation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a Zenko instance and gives it an access token and encryption key
         * @param {string} uuid 
         * @param {InstanceRegisterDataV1} registration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerInstanceInitiate(uuid: string, registration: InstanceRegisterDataV1, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling registerInstanceInitiate.');
            }
            // verify required parameter 'registration' is not null or undefined
            if (registration === null || registration === undefined) {
                throw new RequiredError('registration','Required parameter registration was null or undefined when calling registerInstanceInitiate.');
            }
            const localVarPath = `/instance/{uuid}/register`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InstanceRegisterDataV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(registration || {}) : (registration || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a new stats report
         * @param {string} uuid 
         * @param {ReportV1} report 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveInstanceStats(uuid: string, report: ReportV1, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling saveInstanceStats.');
            }
            // verify required parameter 'report' is not null or undefined
            if (report === null || report === undefined) {
                throw new RequiredError('report','Required parameter report was null or undefined when calling saveInstanceStats.');
            }
            const localVarPath = `/instance/{uuid}/stats`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication managed-instance-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Instance-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Instance-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReportV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(report || {}) : (report || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagedInstanceApi - functional programming interface
 * @export
 */
export const ManagedInstanceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Server-managed configuration values for use by managed instances
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceConfigurationOverlay(uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ConfigOverlayV1> {
            const localVarFetchArgs = ManagedInstanceApiFetchParamCreator(configuration).getInstanceConfigurationOverlay(uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Confirms the instance to indicate that tokens and keys are safely stored
         * @param {string} uuid 
         * @param {InstanceConfirmationDataV1} confirmation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerInstanceConfirm(uuid: string, confirmation: InstanceConfirmationDataV1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ManagedInstanceApiFetchParamCreator(configuration).registerInstanceConfirm(uuid, confirmation, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Registers a Zenko instance and gives it an access token and encryption key
         * @param {string} uuid 
         * @param {InstanceRegisterDataV1} registration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerInstanceInitiate(uuid: string, registration: InstanceRegisterDataV1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InstanceCredentialsV1> {
            const localVarFetchArgs = ManagedInstanceApiFetchParamCreator(configuration).registerInstanceInitiate(uuid, registration, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Submit a new stats report
         * @param {string} uuid 
         * @param {ReportV1} report 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveInstanceStats(uuid: string, report: ReportV1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ReportV1> {
            const localVarFetchArgs = ManagedInstanceApiFetchParamCreator(configuration).saveInstanceStats(uuid, report, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ManagedInstanceApi - factory interface
 * @export
 */
export const ManagedInstanceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get Server-managed configuration values for use by managed instances
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceConfigurationOverlay(uuid: string, options?: any) {
            return ManagedInstanceApiFp(configuration).getInstanceConfigurationOverlay(uuid, options)(fetch, basePath);
        },
        /**
         * Confirms the instance to indicate that tokens and keys are safely stored
         * @param {string} uuid 
         * @param {InstanceConfirmationDataV1} confirmation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerInstanceConfirm(uuid: string, confirmation: InstanceConfirmationDataV1, options?: any) {
            return ManagedInstanceApiFp(configuration).registerInstanceConfirm(uuid, confirmation, options)(fetch, basePath);
        },
        /**
         * Registers a Zenko instance and gives it an access token and encryption key
         * @param {string} uuid 
         * @param {InstanceRegisterDataV1} registration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerInstanceInitiate(uuid: string, registration: InstanceRegisterDataV1, options?: any) {
            return ManagedInstanceApiFp(configuration).registerInstanceInitiate(uuid, registration, options)(fetch, basePath);
        },
        /**
         * Submit a new stats report
         * @param {string} uuid 
         * @param {ReportV1} report 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveInstanceStats(uuid: string, report: ReportV1, options?: any) {
            return ManagedInstanceApiFp(configuration).saveInstanceStats(uuid, report, options)(fetch, basePath);
        },
    };
};

/**
 * ManagedInstanceApi - object-oriented interface
 * @export
 * @class ManagedInstanceApi
 * @extends {BaseAPI}
 */
export class ManagedInstanceApi extends BaseAPI {
    /**
     * Get Server-managed configuration values for use by managed instances
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedInstanceApi
     */
    public getInstanceConfigurationOverlay(uuid: string, options?: any) {
        return ManagedInstanceApiFp(this.configuration).getInstanceConfigurationOverlay(uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Confirms the instance to indicate that tokens and keys are safely stored
     * @param {string} uuid 
     * @param {InstanceConfirmationDataV1} confirmation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedInstanceApi
     */
    public registerInstanceConfirm(uuid: string, confirmation: InstanceConfirmationDataV1, options?: any) {
        return ManagedInstanceApiFp(this.configuration).registerInstanceConfirm(uuid, confirmation, options)(this.fetch, this.basePath);
    }

    /**
     * Registers a Zenko instance and gives it an access token and encryption key
     * @param {string} uuid 
     * @param {InstanceRegisterDataV1} registration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedInstanceApi
     */
    public registerInstanceInitiate(uuid: string, registration: InstanceRegisterDataV1, options?: any) {
        return ManagedInstanceApiFp(this.configuration).registerInstanceInitiate(uuid, registration, options)(this.fetch, this.basePath);
    }

    /**
     * Submit a new stats report
     * @param {string} uuid 
     * @param {ReportV1} report 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedInstanceApi
     */
    public saveInstanceStats(uuid: string, report: ReportV1, options?: any) {
        return ManagedInstanceApiFp(this.configuration).saveInstanceStats(uuid, report, options)(this.fetch, this.basePath);
    }

}

/**
 * PensieveInternalApi - fetch parameter creator
 * @export
 */
export const PensieveInternalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a user profile by its id
         * @param {string} userId 
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrbitUserProfile(userId: string, xScalRequestUids?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getOrbitUserProfile.');
            }
            const localVarPath = `/user/profile/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication internal-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Internal-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Internal-Authentication-Token"] = localVarApiKeyValue;
            }

            if (xScalRequestUids !== undefined && xScalRequestUids !== null) {
                localVarHeaderParameter['X-Scal-Request-Uids'] = String(xScalRequestUids);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user profile by its email
         * @param {string} email 
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrbitUserProfileByEmail(email: string, xScalRequestUids?: string, options: any = {}): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling getOrbitUserProfileByEmail.');
            }
            const localVarPath = `/user/profile/email/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication internal-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Internal-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Internal-Authentication-Token"] = localVarApiKeyValue;
            }

            if (xScalRequestUids !== undefined && xScalRequestUids !== null) {
                localVarHeaderParameter['X-Scal-Request-Uids'] = String(xScalRequestUids);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalInform(xScalRequestUids?: string, options: any = {}): FetchArgs {
            const localVarPath = `/internal/inform`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication internal-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Internal-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Internal-Authentication-Token"] = localVarApiKeyValue;
            }

            if (xScalRequestUids !== undefined && xScalRequestUids !== null) {
                localVarHeaderParameter['X-Scal-Request-Uids'] = String(xScalRequestUids);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a user profile
         * @param {PortalUserV1} user 
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveOrbitUserProfile(user: PortalUserV1, xScalRequestUids?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling saveOrbitUserProfile.');
            }
            const localVarPath = `/user/profile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication internal-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Internal-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Internal-Authentication-Token"] = localVarApiKeyValue;
            }

            if (xScalRequestUids !== undefined && xScalRequestUids !== null) {
                localVarHeaderParameter['X-Scal-Request-Uids'] = String(xScalRequestUids);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PortalUserV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PensieveInternalApi - functional programming interface
 * @export
 */
export const PensieveInternalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a user profile by its id
         * @param {string} userId 
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrbitUserProfile(userId: string, xScalRequestUids?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortalUserV1> {
            const localVarFetchArgs = PensieveInternalApiFetchParamCreator(configuration).getOrbitUserProfile(userId, xScalRequestUids, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a user profile by its email
         * @param {string} email 
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrbitUserProfileByEmail(email: string, xScalRequestUids?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortalUserV1> {
            const localVarFetchArgs = PensieveInternalApiFetchParamCreator(configuration).getOrbitUserProfileByEmail(email, xScalRequestUids, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalInform(xScalRequestUids?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PensieveInternalApiFetchParamCreator(configuration).internalInform(xScalRequestUids, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a user profile
         * @param {PortalUserV1} user 
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveOrbitUserProfile(user: PortalUserV1, xScalRequestUids?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortalUserV1> {
            const localVarFetchArgs = PensieveInternalApiFetchParamCreator(configuration).saveOrbitUserProfile(user, xScalRequestUids, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PensieveInternalApi - factory interface
 * @export
 */
export const PensieveInternalApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a user profile by its id
         * @param {string} userId 
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrbitUserProfile(userId: string, xScalRequestUids?: string, options?: any) {
            return PensieveInternalApiFp(configuration).getOrbitUserProfile(userId, xScalRequestUids, options)(fetch, basePath);
        },
        /**
         * Get a user profile by its email
         * @param {string} email 
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrbitUserProfileByEmail(email: string, xScalRequestUids?: string, options?: any) {
            return PensieveInternalApiFp(configuration).getOrbitUserProfileByEmail(email, xScalRequestUids, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalInform(xScalRequestUids?: string, options?: any) {
            return PensieveInternalApiFp(configuration).internalInform(xScalRequestUids, options)(fetch, basePath);
        },
        /**
         * Create a user profile
         * @param {PortalUserV1} user 
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveOrbitUserProfile(user: PortalUserV1, xScalRequestUids?: string, options?: any) {
            return PensieveInternalApiFp(configuration).saveOrbitUserProfile(user, xScalRequestUids, options)(fetch, basePath);
        },
    };
};

/**
 * PensieveInternalApi - object-oriented interface
 * @export
 * @class PensieveInternalApi
 * @extends {BaseAPI}
 */
export class PensieveInternalApi extends BaseAPI {
    /**
     * Get a user profile by its id
     * @param {string} userId 
     * @param {string} [xScalRequestUids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PensieveInternalApi
     */
    public getOrbitUserProfile(userId: string, xScalRequestUids?: string, options?: any) {
        return PensieveInternalApiFp(this.configuration).getOrbitUserProfile(userId, xScalRequestUids, options)(this.fetch, this.basePath);
    }

    /**
     * Get a user profile by its email
     * @param {string} email 
     * @param {string} [xScalRequestUids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PensieveInternalApi
     */
    public getOrbitUserProfileByEmail(email: string, xScalRequestUids?: string, options?: any) {
        return PensieveInternalApiFp(this.configuration).getOrbitUserProfileByEmail(email, xScalRequestUids, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [xScalRequestUids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PensieveInternalApi
     */
    public internalInform(xScalRequestUids?: string, options?: any) {
        return PensieveInternalApiFp(this.configuration).internalInform(xScalRequestUids, options)(this.fetch, this.basePath);
    }

    /**
     * Create a user profile
     * @param {PortalUserV1} user 
     * @param {string} [xScalRequestUids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PensieveInternalApi
     */
    public saveOrbitUserProfile(user: PortalUserV1, xScalRequestUids?: string, options?: any) {
        return PensieveInternalApiFp(this.configuration).saveOrbitUserProfile(user, xScalRequestUids, options)(this.fetch, this.basePath);
    }

}

/**
 * UiFacingApi - fetch parameter creator
 * @export
 */
export const UiFacingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Claim an instance, linking it to the user's account
         * @param {string} userId 
         * @param {string} instanceId 
         * @param {string} friendlyName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimInstance(userId: string, instanceId: string, friendlyName: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling claimInstance.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling claimInstance.');
            }
            // verify required parameter 'friendlyName' is not null or undefined
            if (friendlyName === null || friendlyName === undefined) {
                throw new RequiredError('friendlyName','Required parameter friendlyName was null or undefined when calling claimInstance.');
            }
            const localVarPath = `/user/{userId}/claim/{instanceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(friendlyName || {}) : (friendlyName || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a bucket expiration workflow.
         * @param {BucketWorkflowExpirationV1} workflow 
         * @param {string} bucketName 
         * @param {string} accountId 
         * @param {string} instanceId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, accountId: string, instanceId: string, roleName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling createBucketWorkflowExpiration.');
            }
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling createBucketWorkflowExpiration.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling createBucketWorkflowExpiration.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling createBucketWorkflowExpiration.');
            }
            const localVarPath = `/instance/{instanceId}/account/{accountId}/bucket/{bucketName}/workflow/expiration`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BucketWorkflowExpirationV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a bucket replication workflow. Will Not enable versioning automatically. Will conflict if a rule already exists on the bucket.
         * @param {ReplicationStreamInternalV1} workflow 
         * @param {string} bucketName 
         * @param {string} accountId 
         * @param {string} instanceId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBucketWorkflowReplication(workflow: ReplicationStreamInternalV1, bucketName: string, accountId: string, instanceId: string, roleName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling createBucketWorkflowReplication.');
            }
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling createBucketWorkflowReplication.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling createBucketWorkflowReplication.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling createBucketWorkflowReplication.');
            }
            const localVarPath = `/instance/{instanceId}/account/{accountId}/bucket/{bucketName}/workflow/replication`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReplicationStreamInternalV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a bucket transition workflow.
         * @param {BucketWorkflowTransitionV2} workflow 
         * @param {string} bucketName 
         * @param {string} accountId 
         * @param {string} instanceId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBucketWorkflowTransition(workflow: BucketWorkflowTransitionV2, bucketName: string, accountId: string, instanceId: string, roleName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling createBucketWorkflowTransition.');
            }
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling createBucketWorkflowTransition.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling createBucketWorkflowTransition.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling createBucketWorkflowTransition.');
            }
            const localVarPath = `/instance/{instanceId}/account/{accountId}/bucket/{bucketName}/workflow/transition`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BucketWorkflowTransitionV2" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a bucket expiration workflow
         * @param {BucketWorkflowExpirationV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling createConfigurationOverlayBucketWorkflowExpiration.');
            }
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling createConfigurationOverlayBucketWorkflowExpiration.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling createConfigurationOverlayBucketWorkflowExpiration.');
            }
            const localVarPath = `/config/instance/{instanceId}/bucket/{bucketName}/workflow/expiration`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BucketWorkflowExpirationV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a bucket transition workflow
         * @param {BucketWorkflowTransitionV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayBucketWorkflowTransition(workflow: BucketWorkflowTransitionV1, bucketName: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling createConfigurationOverlayBucketWorkflowTransition.');
            }
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling createConfigurationOverlayBucketWorkflowTransition.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling createConfigurationOverlayBucketWorkflowTransition.');
            }
            const localVarPath = `/config/instance/{instanceId}/bucket/{bucketName}/workflow/transition`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BucketWorkflowTransitionV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an endpoint configuration item
         * @param {EndpointV1} endpoint 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayEndpoint(endpoint: EndpointV1, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'endpoint' is not null or undefined
            if (endpoint === null || endpoint === undefined) {
                throw new RequiredError('endpoint','Required parameter endpoint was null or undefined when calling createConfigurationOverlayEndpoint.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling createConfigurationOverlayEndpoint.');
            }
            const localVarPath = `/config/{uuid}/endpoint`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EndpointV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(endpoint || {}) : (endpoint || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds location configuration item
         * @param {LocationV1} location 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayLocation(location: LocationV1, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'location' is not null or undefined
            if (location === null || location === undefined) {
                throw new RequiredError('location','Required parameter location was null or undefined when calling createConfigurationOverlayLocation.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling createConfigurationOverlayLocation.');
            }
            const localVarPath = `/config/{uuid}/location`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LocationV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(location || {}) : (location || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates replication stream configuration item
         * @param {ReplicationStreamInternalV1} replicationStream 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayReplicationStream(replicationStream: ReplicationStreamInternalV1, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'replicationStream' is not null or undefined
            if (replicationStream === null || replicationStream === undefined) {
                throw new RequiredError('replicationStream','Required parameter replicationStream was null or undefined when calling createConfigurationOverlayReplicationStream.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling createConfigurationOverlayReplicationStream.');
            }
            const localVarPath = `/config/{uuid}/replication`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReplicationStreamInternalV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(replicationStream || {}) : (replicationStream || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user
         * @param {UserV1} user 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayUser(user: UserV1, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling createConfigurationOverlayUser.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling createConfigurationOverlayUser.');
            }
            const localVarPath = `/config/{uuid}/user`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a bucket expiration workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketWorkflowExpiration(bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling deleteBucketWorkflowExpiration.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling deleteBucketWorkflowExpiration.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling deleteBucketWorkflowExpiration.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling deleteBucketWorkflowExpiration.');
            }
            const localVarPath = `/instance/{instanceId}/account/{accountId}/bucket/{bucketName}/workflow/expiration/{workflowId}`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a bucket replication workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketWorkflowReplication(bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling deleteBucketWorkflowReplication.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling deleteBucketWorkflowReplication.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling deleteBucketWorkflowReplication.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling deleteBucketWorkflowReplication.');
            }
            const localVarPath = `/instance/{instanceId}/account/{accountId}/bucket/{bucketName}/workflow/replication/{workflowId}`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a bucket transition workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketWorkflowTransition(bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling deleteBucketWorkflowTransition.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling deleteBucketWorkflowTransition.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling deleteBucketWorkflowTransition.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling deleteBucketWorkflowTransition.');
            }
            const localVarPath = `/instance/{instanceId}/account/{accountId}/bucket/{bucketName}/workflow/transition/{workflowId}`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a bucket expiration workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayBucketWorkflowExpiration(bucketName: string, instanceId: string, workflowId: string, options: any = {}): FetchArgs {
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling deleteConfigurationOverlayBucketWorkflowExpiration.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling deleteConfigurationOverlayBucketWorkflowExpiration.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling deleteConfigurationOverlayBucketWorkflowExpiration.');
            }
            const localVarPath = `/config/instance/{instanceId}/bucket/{bucketName}/workflow/expiration/{workflowId}`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a bucket transition workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayBucketWorkflowTransition(bucketName: string, instanceId: string, workflowId: string, options: any = {}): FetchArgs {
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling deleteConfigurationOverlayBucketWorkflowTransition.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling deleteConfigurationOverlayBucketWorkflowTransition.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling deleteConfigurationOverlayBucketWorkflowTransition.');
            }
            const localVarPath = `/config/instance/{instanceId}/bucket/{bucketName}/workflow/transition/{workflowId}`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an endpoint definition
         * @param {string} hostname 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayEndpoint(hostname: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'hostname' is not null or undefined
            if (hostname === null || hostname === undefined) {
                throw new RequiredError('hostname','Required parameter hostname was null or undefined when calling deleteConfigurationOverlayEndpoint.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteConfigurationOverlayEndpoint.');
            }
            const localVarPath = `/config/{uuid}/endpoint/{hostname}`
                .replace(`{${"hostname"}}`, encodeURIComponent(String(hostname)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes location configuration item
         * @param {string} locationName 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayLocation(locationName: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'locationName' is not null or undefined
            if (locationName === null || locationName === undefined) {
                throw new RequiredError('locationName','Required parameter locationName was null or undefined when calling deleteConfigurationOverlayLocation.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteConfigurationOverlayLocation.');
            }
            const localVarPath = `/config/{uuid}/location/{locationName}`
                .replace(`{${"locationName"}}`, encodeURIComponent(String(locationName)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a replication stream
         * @param {string} streamId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayReplicationStream(streamId: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'streamId' is not null or undefined
            if (streamId === null || streamId === undefined) {
                throw new RequiredError('streamId','Required parameter streamId was null or undefined when calling deleteConfigurationOverlayReplicationStream.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteConfigurationOverlayReplicationStream.');
            }
            const localVarPath = `/config/{uuid}/replication/{streamId}`
                .replace(`{${"streamId"}}`, encodeURIComponent(String(streamId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user
         * @param {string} uuid 
         * @param {string} [accessKey] 
         * @param {string} [accountName] 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayUser(uuid: string, accessKey?: string, accountName?: string, roleName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteConfigurationOverlayUser.');
            }
            const localVarPath = `/config/{uuid}/user`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (accessKey !== undefined) {
                localVarQueryParameter['accessKey'] = accessKey;
            }

            if (accountName !== undefined) {
                localVarQueryParameter['accountName'] = accountName;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate account access key
         * @param {string} uuid 
         * @param {string} accountName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKeyConfigurationOverlayUser(uuid: string, accountName: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling generateKeyConfigurationOverlayUser.');
            }
            // verify required parameter 'accountName' is not null or undefined
            if (accountName === null || accountName === undefined) {
                throw new RequiredError('accountName','Required parameter accountName was null or undefined when calling generateKeyConfigurationOverlayUser.');
            }
            const localVarPath = `/config/{uuid}/user/{accountName}/key`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"accountName"}}`, encodeURIComponent(String(accountName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server-managed configuration values for use by user frontend
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationOverlayView(uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getConfigurationOverlayView.');
            }
            const localVarPath = `/config/overlay/view/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user's profile
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserProfile(xScalRequestUids?: string, options: any = {}): FetchArgs {
            const localVarPath = `/profile/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (xScalRequestUids !== undefined && xScalRequestUids !== null) {
                localVarHeaderParameter['X-Scal-Request-Uids'] = String(xScalRequestUids);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get instance
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance(uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getInstance.');
            }
            const localVarPath = `/instance/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get latest statistics
         * @param {string} uuid 
         * @param {number} [interval] 
         * @param {string} [startTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceStats(uuid: string, interval?: number, startTime?: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getInstanceStats.');
            }
            const localVarPath = `/stats/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get latest instance status snapshot
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestInstanceStatus(uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getLatestInstanceStatus.');
            }
            const localVarPath = `/instance/{uuid}/status`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite users by email
         * @param {string} userId 
         * @param {Array<any>} invites 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteOrbitUsersByEmail(userId: string, invites: Array<any>, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling inviteOrbitUsersByEmail.');
            }
            // verify required parameter 'invites' is not null or undefined
            if (invites === null || invites === undefined) {
                throw new RequiredError('invites','Required parameter invites was null or undefined when calling inviteOrbitUsersByEmail.');
            }
            const localVarPath = `/user/{userId}/invite`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;any&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(invites || {}) : (invites || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new managed Zenko instance
         * @param {string} [instanceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionHostedInstance(instanceName?: string, options: any = {}): FetchArgs {
            const localVarPath = `/instance/type/managed/provision`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(instanceName || {}) : (instanceName || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Regenerate a user's secret key
         * @param {string} accessKey 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rekeyConfigurationOverlayUser(accessKey: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'accessKey' is not null or undefined
            if (accessKey === null || accessKey === undefined) {
                throw new RequiredError('accessKey','Required parameter accessKey was null or undefined when calling rekeyConfigurationOverlayUser.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling rekeyConfigurationOverlayUser.');
            }
            const localVarPath = `/config/{uuid}/user/{accessKey}`
                .replace(`{${"accessKey"}}`, encodeURIComponent(String(accessKey)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a search of bucket workflows. Currently returns replication and lifecycle workflows. Filtering ability is limited to all buckets or a list of buckets. 
         * @param {string} accountId 
         * @param {string} instanceId 
         * @param {string} [roleName] 
         * @param {Filters} [filters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorkflows(accountId: string, instanceId: string, roleName?: string, filters?: Filters, options: any = {}): FetchArgs {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling searchWorkflows.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling searchWorkflows.');
            }
            const localVarPath = `/instance/{instanceId}/account/{accountId}/workflow/search`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Filters" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(filters || {}) : (filters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Un-claim an instance, deleting it from the user's account
         * @param {string} userId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclaimInstance(userId: string, instanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling unclaimInstance.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling unclaimInstance.');
            }
            const localVarPath = `/user/{userId}/claim/{instanceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a bucket expiration workflow
         * @param {BucketWorkflowExpirationV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling updateBucketWorkflowExpiration.');
            }
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling updateBucketWorkflowExpiration.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling updateBucketWorkflowExpiration.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling updateBucketWorkflowExpiration.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling updateBucketWorkflowExpiration.');
            }
            const localVarPath = `/instance/{instanceId}/account/{accountId}/bucket/{bucketName}/workflow/expiration/{workflowId}`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BucketWorkflowExpirationV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a bucket replication workflow
         * @param {ReplicationStreamInternalV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBucketWorkflowReplication(workflow: ReplicationStreamInternalV1, bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling updateBucketWorkflowReplication.');
            }
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling updateBucketWorkflowReplication.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling updateBucketWorkflowReplication.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling updateBucketWorkflowReplication.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling updateBucketWorkflowReplication.');
            }
            const localVarPath = `/instance/{instanceId}/account/{accountId}/bucket/{bucketName}/workflow/replication/{workflowId}`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReplicationStreamInternalV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a bucket transition workflow
         * @param {BucketWorkflowTransitionV2} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBucketWorkflowTransition(workflow: BucketWorkflowTransitionV2, bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling updateBucketWorkflowTransition.');
            }
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling updateBucketWorkflowTransition.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling updateBucketWorkflowTransition.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling updateBucketWorkflowTransition.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling updateBucketWorkflowTransition.');
            }
            const localVarPath = `/instance/{instanceId}/account/{accountId}/bucket/{bucketName}/workflow/transition/{workflowId}`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['roleName'] = roleName;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BucketWorkflowTransitionV2" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updates a bucket expiration workflow
         * @param {BucketWorkflowExpirationV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationOverlayBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, instanceId: string, workflowId: string, options: any = {}): FetchArgs {
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling updateConfigurationOverlayBucketWorkflowExpiration.');
            }
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling updateConfigurationOverlayBucketWorkflowExpiration.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling updateConfigurationOverlayBucketWorkflowExpiration.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling updateConfigurationOverlayBucketWorkflowExpiration.');
            }
            const localVarPath = `/config/instance/{instanceId}/bucket/{bucketName}/workflow/expiration/{workflowId}`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BucketWorkflowExpirationV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updates a bucket transition workflow
         * @param {BucketWorkflowTransitionV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationOverlayBucketWorkflowTransition(workflow: BucketWorkflowTransitionV1, bucketName: string, instanceId: string, workflowId: string, options: any = {}): FetchArgs {
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling updateConfigurationOverlayBucketWorkflowTransition.');
            }
            // verify required parameter 'bucketName' is not null or undefined
            if (bucketName === null || bucketName === undefined) {
                throw new RequiredError('bucketName','Required parameter bucketName was null or undefined when calling updateConfigurationOverlayBucketWorkflowTransition.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling updateConfigurationOverlayBucketWorkflowTransition.');
            }
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling updateConfigurationOverlayBucketWorkflowTransition.');
            }
            const localVarPath = `/config/instance/{instanceId}/bucket/{bucketName}/workflow/transition/{workflowId}`
                .replace(`{${"bucketName"}}`, encodeURIComponent(String(bucketName)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BucketWorkflowTransitionV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a location configuration item
         * @param {string} locationName 
         * @param {string} uuid 
         * @param {LocationV1} location 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationOverlayLocation(locationName: string, uuid: string, location: LocationV1, options: any = {}): FetchArgs {
            // verify required parameter 'locationName' is not null or undefined
            if (locationName === null || locationName === undefined) {
                throw new RequiredError('locationName','Required parameter locationName was null or undefined when calling updateConfigurationOverlayLocation.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling updateConfigurationOverlayLocation.');
            }
            // verify required parameter 'location' is not null or undefined
            if (location === null || location === undefined) {
                throw new RequiredError('location','Required parameter location was null or undefined when calling updateConfigurationOverlayLocation.');
            }
            const localVarPath = `/config/{uuid}/location/{locationName}`
                .replace(`{${"locationName"}}`, encodeURIComponent(String(locationName)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LocationV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(location || {}) : (location || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a replication stream
         * @param {string} streamId 
         * @param {ReplicationStreamInternalV1} replicationStream 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationOverlayReplicationStream(streamId: string, replicationStream: ReplicationStreamInternalV1, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'streamId' is not null or undefined
            if (streamId === null || streamId === undefined) {
                throw new RequiredError('streamId','Required parameter streamId was null or undefined when calling updateConfigurationOverlayReplicationStream.');
            }
            // verify required parameter 'replicationStream' is not null or undefined
            if (replicationStream === null || replicationStream === undefined) {
                throw new RequiredError('replicationStream','Required parameter replicationStream was null or undefined when calling updateConfigurationOverlayReplicationStream.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling updateConfigurationOverlayReplicationStream.');
            }
            const localVarPath = `/config/{uuid}/replication/{streamId}`
                .replace(`{${"streamId"}}`, encodeURIComponent(String(streamId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication public-api required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-Authentication-Token")
					: configuration.apiKey;
                localVarHeaderParameter["X-Authentication-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReplicationStreamInternalV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(replicationStream || {}) : (replicationStream || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UiFacingApi - functional programming interface
 * @export
 */
export const UiFacingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Claim an instance, linking it to the user's account
         * @param {string} userId 
         * @param {string} instanceId 
         * @param {string} friendlyName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimInstance(userId: string, instanceId: string, friendlyName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortalUserV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).claimInstance(userId, instanceId, friendlyName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a bucket expiration workflow.
         * @param {BucketWorkflowExpirationV1} workflow 
         * @param {string} bucketName 
         * @param {string} accountId 
         * @param {string} instanceId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, accountId: string, instanceId: string, roleName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BucketWorkflowExpirationV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).createBucketWorkflowExpiration(workflow, bucketName, accountId, instanceId, roleName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a bucket replication workflow. Will Not enable versioning automatically. Will conflict if a rule already exists on the bucket.
         * @param {ReplicationStreamInternalV1} workflow 
         * @param {string} bucketName 
         * @param {string} accountId 
         * @param {string} instanceId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBucketWorkflowReplication(workflow: ReplicationStreamInternalV1, bucketName: string, accountId: string, instanceId: string, roleName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ReplicationStreamInternalV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).createBucketWorkflowReplication(workflow, bucketName, accountId, instanceId, roleName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a bucket transition workflow.
         * @param {BucketWorkflowTransitionV2} workflow 
         * @param {string} bucketName 
         * @param {string} accountId 
         * @param {string} instanceId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBucketWorkflowTransition(workflow: BucketWorkflowTransitionV2, bucketName: string, accountId: string, instanceId: string, roleName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BucketWorkflowTransitionV2> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).createBucketWorkflowTransition(workflow, bucketName, accountId, instanceId, roleName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a bucket expiration workflow
         * @param {BucketWorkflowExpirationV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BucketWorkflowExpirationV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).createConfigurationOverlayBucketWorkflowExpiration(workflow, bucketName, instanceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a bucket transition workflow
         * @param {BucketWorkflowTransitionV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayBucketWorkflowTransition(workflow: BucketWorkflowTransitionV1, bucketName: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BucketWorkflowTransitionV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).createConfigurationOverlayBucketWorkflowTransition(workflow, bucketName, instanceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds an endpoint configuration item
         * @param {EndpointV1} endpoint 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayEndpoint(endpoint: EndpointV1, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EndpointV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).createConfigurationOverlayEndpoint(endpoint, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds location configuration item
         * @param {LocationV1} location 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayLocation(location: LocationV1, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).createConfigurationOverlayLocation(location, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates replication stream configuration item
         * @param {ReplicationStreamInternalV1} replicationStream 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayReplicationStream(replicationStream: ReplicationStreamInternalV1, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ReplicationStreamInternalV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).createConfigurationOverlayReplicationStream(replicationStream, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new user
         * @param {UserV1} user 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayUser(user: UserV1, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).createConfigurationOverlayUser(user, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a bucket expiration workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketWorkflowExpiration(bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).deleteBucketWorkflowExpiration(bucketName, instanceId, accountId, workflowId, roleName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a bucket replication workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketWorkflowReplication(bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).deleteBucketWorkflowReplication(bucketName, instanceId, accountId, workflowId, roleName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a bucket transition workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketWorkflowTransition(bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).deleteBucketWorkflowTransition(bucketName, instanceId, accountId, workflowId, roleName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a bucket expiration workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayBucketWorkflowExpiration(bucketName: string, instanceId: string, workflowId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).deleteConfigurationOverlayBucketWorkflowExpiration(bucketName, instanceId, workflowId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a bucket transition workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayBucketWorkflowTransition(bucketName: string, instanceId: string, workflowId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).deleteConfigurationOverlayBucketWorkflowTransition(bucketName, instanceId, workflowId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an endpoint definition
         * @param {string} hostname 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayEndpoint(hostname: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).deleteConfigurationOverlayEndpoint(hostname, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes location configuration item
         * @param {string} locationName 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayLocation(locationName: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).deleteConfigurationOverlayLocation(locationName, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a replication stream
         * @param {string} streamId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayReplicationStream(streamId: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).deleteConfigurationOverlayReplicationStream(streamId, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a user
         * @param {string} uuid 
         * @param {string} [accessKey] 
         * @param {string} [accountName] 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayUser(uuid: string, accessKey?: string, accountName?: string, roleName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).deleteConfigurationOverlayUser(uuid, accessKey, accountName, roleName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generate account access key
         * @param {string} uuid 
         * @param {string} accountName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKeyConfigurationOverlayUser(uuid: string, accountName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).generateKeyConfigurationOverlayUser(uuid, accountName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Server-managed configuration values for use by user frontend
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationOverlayView(uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ConfigOverlayV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).getConfigurationOverlayView(uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get current user's profile
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserProfile(xScalRequestUids?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortalUserV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).getCurrentUserProfile(xScalRequestUids, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get instance
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance(uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InstanceV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).getInstance(uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get latest statistics
         * @param {string} uuid 
         * @param {number} [interval] 
         * @param {string} [startTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceStats(uuid: string, interval?: number, startTime?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AllStatsSeriesV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).getInstanceStats(uuid, interval, startTime, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get latest instance status snapshot
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestInstanceStatus(uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).getLatestInstanceStatus(uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Invite users by email
         * @param {string} userId 
         * @param {Array<any>} invites 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteOrbitUsersByEmail(userId: string, invites: Array<any>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).inviteOrbitUsersByEmail(userId, invites, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new managed Zenko instance
         * @param {string} [instanceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionHostedInstance(instanceName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InstanceV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).provisionHostedInstance(instanceName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Regenerate a user's secret key
         * @param {string} accessKey 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rekeyConfigurationOverlayUser(accessKey: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).rekeyConfigurationOverlayUser(accessKey, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Performs a search of bucket workflows. Currently returns replication and lifecycle workflows. Filtering ability is limited to all buckets or a list of buckets. 
         * @param {string} accountId 
         * @param {string} instanceId 
         * @param {string} [roleName] 
         * @param {Filters} [filters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorkflows(accountId: string, instanceId: string, roleName?: string, filters?: Filters, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchWorkflowsListV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).searchWorkflows(accountId, instanceId, roleName, filters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Un-claim an instance, deleting it from the user's account
         * @param {string} userId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclaimInstance(userId: string, instanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortalUserV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).unclaimInstance(userId, instanceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a bucket expiration workflow
         * @param {BucketWorkflowExpirationV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BucketWorkflowExpirationV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).updateBucketWorkflowExpiration(workflow, bucketName, instanceId, accountId, workflowId, roleName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a bucket replication workflow
         * @param {ReplicationStreamInternalV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBucketWorkflowReplication(workflow: ReplicationStreamInternalV1, bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ReplicationStreamInternalV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).updateBucketWorkflowReplication(workflow, bucketName, instanceId, accountId, workflowId, roleName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a bucket transition workflow
         * @param {BucketWorkflowTransitionV2} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBucketWorkflowTransition(workflow: BucketWorkflowTransitionV2, bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BucketWorkflowTransitionV2> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).updateBucketWorkflowTransition(workflow, bucketName, instanceId, accountId, workflowId, roleName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * updates a bucket expiration workflow
         * @param {BucketWorkflowExpirationV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationOverlayBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, instanceId: string, workflowId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BucketWorkflowExpirationV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).updateConfigurationOverlayBucketWorkflowExpiration(workflow, bucketName, instanceId, workflowId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * updates a bucket transition workflow
         * @param {BucketWorkflowTransitionV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationOverlayBucketWorkflowTransition(workflow: BucketWorkflowTransitionV1, bucketName: string, instanceId: string, workflowId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BucketWorkflowTransitionV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).updateConfigurationOverlayBucketWorkflowTransition(workflow, bucketName, instanceId, workflowId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a location configuration item
         * @param {string} locationName 
         * @param {string} uuid 
         * @param {LocationV1} location 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationOverlayLocation(locationName: string, uuid: string, location: LocationV1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LocationV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).updateConfigurationOverlayLocation(locationName, uuid, location, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a replication stream
         * @param {string} streamId 
         * @param {ReplicationStreamInternalV1} replicationStream 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationOverlayReplicationStream(streamId: string, replicationStream: ReplicationStreamInternalV1, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ReplicationStreamInternalV1> {
            const localVarFetchArgs = UiFacingApiFetchParamCreator(configuration).updateConfigurationOverlayReplicationStream(streamId, replicationStream, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UiFacingApi - factory interface
 * @export
 */
export const UiFacingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Claim an instance, linking it to the user's account
         * @param {string} userId 
         * @param {string} instanceId 
         * @param {string} friendlyName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimInstance(userId: string, instanceId: string, friendlyName: string, options?: any) {
            return UiFacingApiFp(configuration).claimInstance(userId, instanceId, friendlyName, options)(fetch, basePath);
        },
        /**
         * Creates a bucket expiration workflow.
         * @param {BucketWorkflowExpirationV1} workflow 
         * @param {string} bucketName 
         * @param {string} accountId 
         * @param {string} instanceId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, accountId: string, instanceId: string, roleName?: string, options?: any) {
            return UiFacingApiFp(configuration).createBucketWorkflowExpiration(workflow, bucketName, accountId, instanceId, roleName, options)(fetch, basePath);
        },
        /**
         * Creates a bucket replication workflow. Will Not enable versioning automatically. Will conflict if a rule already exists on the bucket.
         * @param {ReplicationStreamInternalV1} workflow 
         * @param {string} bucketName 
         * @param {string} accountId 
         * @param {string} instanceId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBucketWorkflowReplication(workflow: ReplicationStreamInternalV1, bucketName: string, accountId: string, instanceId: string, roleName?: string, options?: any) {
            return UiFacingApiFp(configuration).createBucketWorkflowReplication(workflow, bucketName, accountId, instanceId, roleName, options)(fetch, basePath);
        },
        /**
         * Creates a bucket transition workflow.
         * @param {BucketWorkflowTransitionV2} workflow 
         * @param {string} bucketName 
         * @param {string} accountId 
         * @param {string} instanceId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBucketWorkflowTransition(workflow: BucketWorkflowTransitionV2, bucketName: string, accountId: string, instanceId: string, roleName?: string, options?: any) {
            return UiFacingApiFp(configuration).createBucketWorkflowTransition(workflow, bucketName, accountId, instanceId, roleName, options)(fetch, basePath);
        },
        /**
         * Creates a bucket expiration workflow
         * @param {BucketWorkflowExpirationV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, instanceId: string, options?: any) {
            return UiFacingApiFp(configuration).createConfigurationOverlayBucketWorkflowExpiration(workflow, bucketName, instanceId, options)(fetch, basePath);
        },
        /**
         * Creates a bucket transition workflow
         * @param {BucketWorkflowTransitionV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayBucketWorkflowTransition(workflow: BucketWorkflowTransitionV1, bucketName: string, instanceId: string, options?: any) {
            return UiFacingApiFp(configuration).createConfigurationOverlayBucketWorkflowTransition(workflow, bucketName, instanceId, options)(fetch, basePath);
        },
        /**
         * Adds an endpoint configuration item
         * @param {EndpointV1} endpoint 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayEndpoint(endpoint: EndpointV1, uuid: string, options?: any) {
            return UiFacingApiFp(configuration).createConfigurationOverlayEndpoint(endpoint, uuid, options)(fetch, basePath);
        },
        /**
         * Adds location configuration item
         * @param {LocationV1} location 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayLocation(location: LocationV1, uuid: string, options?: any) {
            return UiFacingApiFp(configuration).createConfigurationOverlayLocation(location, uuid, options)(fetch, basePath);
        },
        /**
         * Creates replication stream configuration item
         * @param {ReplicationStreamInternalV1} replicationStream 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayReplicationStream(replicationStream: ReplicationStreamInternalV1, uuid: string, options?: any) {
            return UiFacingApiFp(configuration).createConfigurationOverlayReplicationStream(replicationStream, uuid, options)(fetch, basePath);
        },
        /**
         * Create a new user
         * @param {UserV1} user 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfigurationOverlayUser(user: UserV1, uuid: string, options?: any) {
            return UiFacingApiFp(configuration).createConfigurationOverlayUser(user, uuid, options)(fetch, basePath);
        },
        /**
         * Deletes a bucket expiration workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketWorkflowExpiration(bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any) {
            return UiFacingApiFp(configuration).deleteBucketWorkflowExpiration(bucketName, instanceId, accountId, workflowId, roleName, options)(fetch, basePath);
        },
        /**
         * Deletes a bucket replication workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketWorkflowReplication(bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any) {
            return UiFacingApiFp(configuration).deleteBucketWorkflowReplication(bucketName, instanceId, accountId, workflowId, roleName, options)(fetch, basePath);
        },
        /**
         * Deletes a bucket transition workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBucketWorkflowTransition(bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any) {
            return UiFacingApiFp(configuration).deleteBucketWorkflowTransition(bucketName, instanceId, accountId, workflowId, roleName, options)(fetch, basePath);
        },
        /**
         * Deletes a bucket expiration workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayBucketWorkflowExpiration(bucketName: string, instanceId: string, workflowId: string, options?: any) {
            return UiFacingApiFp(configuration).deleteConfigurationOverlayBucketWorkflowExpiration(bucketName, instanceId, workflowId, options)(fetch, basePath);
        },
        /**
         * Deletes a bucket transition workflow
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayBucketWorkflowTransition(bucketName: string, instanceId: string, workflowId: string, options?: any) {
            return UiFacingApiFp(configuration).deleteConfigurationOverlayBucketWorkflowTransition(bucketName, instanceId, workflowId, options)(fetch, basePath);
        },
        /**
         * Delete an endpoint definition
         * @param {string} hostname 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayEndpoint(hostname: string, uuid: string, options?: any) {
            return UiFacingApiFp(configuration).deleteConfigurationOverlayEndpoint(hostname, uuid, options)(fetch, basePath);
        },
        /**
         * Deletes location configuration item
         * @param {string} locationName 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayLocation(locationName: string, uuid: string, options?: any) {
            return UiFacingApiFp(configuration).deleteConfigurationOverlayLocation(locationName, uuid, options)(fetch, basePath);
        },
        /**
         * Deletes a replication stream
         * @param {string} streamId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayReplicationStream(streamId: string, uuid: string, options?: any) {
            return UiFacingApiFp(configuration).deleteConfigurationOverlayReplicationStream(streamId, uuid, options)(fetch, basePath);
        },
        /**
         * Delete a user
         * @param {string} uuid 
         * @param {string} [accessKey] 
         * @param {string} [accountName] 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConfigurationOverlayUser(uuid: string, accessKey?: string, accountName?: string, roleName?: string, options?: any) {
            return UiFacingApiFp(configuration).deleteConfigurationOverlayUser(uuid, accessKey, accountName, roleName, options)(fetch, basePath);
        },
        /**
         * Generate account access key
         * @param {string} uuid 
         * @param {string} accountName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateKeyConfigurationOverlayUser(uuid: string, accountName: string, options?: any) {
            return UiFacingApiFp(configuration).generateKeyConfigurationOverlayUser(uuid, accountName, options)(fetch, basePath);
        },
        /**
         * Get Server-managed configuration values for use by user frontend
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationOverlayView(uuid: string, options?: any) {
            return UiFacingApiFp(configuration).getConfigurationOverlayView(uuid, options)(fetch, basePath);
        },
        /**
         * Get current user's profile
         * @param {string} [xScalRequestUids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserProfile(xScalRequestUids?: string, options?: any) {
            return UiFacingApiFp(configuration).getCurrentUserProfile(xScalRequestUids, options)(fetch, basePath);
        },
        /**
         * Get instance
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstance(uuid: string, options?: any) {
            return UiFacingApiFp(configuration).getInstance(uuid, options)(fetch, basePath);
        },
        /**
         * Get latest statistics
         * @param {string} uuid 
         * @param {number} [interval] 
         * @param {string} [startTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceStats(uuid: string, interval?: number, startTime?: string, options?: any) {
            return UiFacingApiFp(configuration).getInstanceStats(uuid, interval, startTime, options)(fetch, basePath);
        },
        /**
         * Get latest instance status snapshot
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestInstanceStatus(uuid: string, options?: any) {
            return UiFacingApiFp(configuration).getLatestInstanceStatus(uuid, options)(fetch, basePath);
        },
        /**
         * Invite users by email
         * @param {string} userId 
         * @param {Array<any>} invites 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteOrbitUsersByEmail(userId: string, invites: Array<any>, options?: any) {
            return UiFacingApiFp(configuration).inviteOrbitUsersByEmail(userId, invites, options)(fetch, basePath);
        },
        /**
         * Create a new managed Zenko instance
         * @param {string} [instanceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionHostedInstance(instanceName?: string, options?: any) {
            return UiFacingApiFp(configuration).provisionHostedInstance(instanceName, options)(fetch, basePath);
        },
        /**
         * Regenerate a user's secret key
         * @param {string} accessKey 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rekeyConfigurationOverlayUser(accessKey: string, uuid: string, options?: any) {
            return UiFacingApiFp(configuration).rekeyConfigurationOverlayUser(accessKey, uuid, options)(fetch, basePath);
        },
        /**
         * Performs a search of bucket workflows. Currently returns replication and lifecycle workflows. Filtering ability is limited to all buckets or a list of buckets. 
         * @param {string} accountId 
         * @param {string} instanceId 
         * @param {string} [roleName] 
         * @param {Filters} [filters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorkflows(accountId: string, instanceId: string, roleName?: string, filters?: Filters, options?: any) {
            return UiFacingApiFp(configuration).searchWorkflows(accountId, instanceId, roleName, filters, options)(fetch, basePath);
        },
        /**
         * Un-claim an instance, deleting it from the user's account
         * @param {string} userId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclaimInstance(userId: string, instanceId: string, options?: any) {
            return UiFacingApiFp(configuration).unclaimInstance(userId, instanceId, options)(fetch, basePath);
        },
        /**
         * Updates a bucket expiration workflow
         * @param {BucketWorkflowExpirationV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any) {
            return UiFacingApiFp(configuration).updateBucketWorkflowExpiration(workflow, bucketName, instanceId, accountId, workflowId, roleName, options)(fetch, basePath);
        },
        /**
         * Updates a bucket replication workflow
         * @param {ReplicationStreamInternalV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBucketWorkflowReplication(workflow: ReplicationStreamInternalV1, bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any) {
            return UiFacingApiFp(configuration).updateBucketWorkflowReplication(workflow, bucketName, instanceId, accountId, workflowId, roleName, options)(fetch, basePath);
        },
        /**
         * Updates a bucket transition workflow
         * @param {BucketWorkflowTransitionV2} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} accountId 
         * @param {string} workflowId 
         * @param {string} [roleName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBucketWorkflowTransition(workflow: BucketWorkflowTransitionV2, bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any) {
            return UiFacingApiFp(configuration).updateBucketWorkflowTransition(workflow, bucketName, instanceId, accountId, workflowId, roleName, options)(fetch, basePath);
        },
        /**
         * updates a bucket expiration workflow
         * @param {BucketWorkflowExpirationV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationOverlayBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, instanceId: string, workflowId: string, options?: any) {
            return UiFacingApiFp(configuration).updateConfigurationOverlayBucketWorkflowExpiration(workflow, bucketName, instanceId, workflowId, options)(fetch, basePath);
        },
        /**
         * updates a bucket transition workflow
         * @param {BucketWorkflowTransitionV1} workflow 
         * @param {string} bucketName 
         * @param {string} instanceId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationOverlayBucketWorkflowTransition(workflow: BucketWorkflowTransitionV1, bucketName: string, instanceId: string, workflowId: string, options?: any) {
            return UiFacingApiFp(configuration).updateConfigurationOverlayBucketWorkflowTransition(workflow, bucketName, instanceId, workflowId, options)(fetch, basePath);
        },
        /**
         * Updates a location configuration item
         * @param {string} locationName 
         * @param {string} uuid 
         * @param {LocationV1} location 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationOverlayLocation(locationName: string, uuid: string, location: LocationV1, options?: any) {
            return UiFacingApiFp(configuration).updateConfigurationOverlayLocation(locationName, uuid, location, options)(fetch, basePath);
        },
        /**
         * Updates a replication stream
         * @param {string} streamId 
         * @param {ReplicationStreamInternalV1} replicationStream 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationOverlayReplicationStream(streamId: string, replicationStream: ReplicationStreamInternalV1, uuid: string, options?: any) {
            return UiFacingApiFp(configuration).updateConfigurationOverlayReplicationStream(streamId, replicationStream, uuid, options)(fetch, basePath);
        },
    };
};

/**
 * UiFacingApi - object-oriented interface
 * @export
 * @class UiFacingApi
 * @extends {BaseAPI}
 */
export class UiFacingApi extends BaseAPI {
    /**
     * Claim an instance, linking it to the user's account
     * @param {string} userId 
     * @param {string} instanceId 
     * @param {string} friendlyName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public claimInstance(userId: string, instanceId: string, friendlyName: string, options?: any) {
        return UiFacingApiFp(this.configuration).claimInstance(userId, instanceId, friendlyName, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a bucket expiration workflow.
     * @param {BucketWorkflowExpirationV1} workflow 
     * @param {string} bucketName 
     * @param {string} accountId 
     * @param {string} instanceId 
     * @param {string} [roleName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public createBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, accountId: string, instanceId: string, roleName?: string, options?: any) {
        return UiFacingApiFp(this.configuration).createBucketWorkflowExpiration(workflow, bucketName, accountId, instanceId, roleName, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a bucket replication workflow. Will Not enable versioning automatically. Will conflict if a rule already exists on the bucket.
     * @param {ReplicationStreamInternalV1} workflow 
     * @param {string} bucketName 
     * @param {string} accountId 
     * @param {string} instanceId 
     * @param {string} [roleName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public createBucketWorkflowReplication(workflow: ReplicationStreamInternalV1, bucketName: string, accountId: string, instanceId: string, roleName?: string, options?: any) {
        return UiFacingApiFp(this.configuration).createBucketWorkflowReplication(workflow, bucketName, accountId, instanceId, roleName, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a bucket transition workflow.
     * @param {BucketWorkflowTransitionV2} workflow 
     * @param {string} bucketName 
     * @param {string} accountId 
     * @param {string} instanceId 
     * @param {string} [roleName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public createBucketWorkflowTransition(workflow: BucketWorkflowTransitionV2, bucketName: string, accountId: string, instanceId: string, roleName?: string, options?: any) {
        return UiFacingApiFp(this.configuration).createBucketWorkflowTransition(workflow, bucketName, accountId, instanceId, roleName, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a bucket expiration workflow
     * @param {BucketWorkflowExpirationV1} workflow 
     * @param {string} bucketName 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public createConfigurationOverlayBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, instanceId: string, options?: any) {
        return UiFacingApiFp(this.configuration).createConfigurationOverlayBucketWorkflowExpiration(workflow, bucketName, instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a bucket transition workflow
     * @param {BucketWorkflowTransitionV1} workflow 
     * @param {string} bucketName 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public createConfigurationOverlayBucketWorkflowTransition(workflow: BucketWorkflowTransitionV1, bucketName: string, instanceId: string, options?: any) {
        return UiFacingApiFp(this.configuration).createConfigurationOverlayBucketWorkflowTransition(workflow, bucketName, instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * Adds an endpoint configuration item
     * @param {EndpointV1} endpoint 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public createConfigurationOverlayEndpoint(endpoint: EndpointV1, uuid: string, options?: any) {
        return UiFacingApiFp(this.configuration).createConfigurationOverlayEndpoint(endpoint, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Adds location configuration item
     * @param {LocationV1} location 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public createConfigurationOverlayLocation(location: LocationV1, uuid: string, options?: any) {
        return UiFacingApiFp(this.configuration).createConfigurationOverlayLocation(location, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Creates replication stream configuration item
     * @param {ReplicationStreamInternalV1} replicationStream 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public createConfigurationOverlayReplicationStream(replicationStream: ReplicationStreamInternalV1, uuid: string, options?: any) {
        return UiFacingApiFp(this.configuration).createConfigurationOverlayReplicationStream(replicationStream, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new user
     * @param {UserV1} user 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public createConfigurationOverlayUser(user: UserV1, uuid: string, options?: any) {
        return UiFacingApiFp(this.configuration).createConfigurationOverlayUser(user, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a bucket expiration workflow
     * @param {string} bucketName 
     * @param {string} instanceId 
     * @param {string} accountId 
     * @param {string} workflowId 
     * @param {string} [roleName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public deleteBucketWorkflowExpiration(bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any) {
        return UiFacingApiFp(this.configuration).deleteBucketWorkflowExpiration(bucketName, instanceId, accountId, workflowId, roleName, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a bucket replication workflow
     * @param {string} bucketName 
     * @param {string} instanceId 
     * @param {string} accountId 
     * @param {string} workflowId 
     * @param {string} [roleName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public deleteBucketWorkflowReplication(bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any) {
        return UiFacingApiFp(this.configuration).deleteBucketWorkflowReplication(bucketName, instanceId, accountId, workflowId, roleName, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a bucket transition workflow
     * @param {string} bucketName 
     * @param {string} instanceId 
     * @param {string} accountId 
     * @param {string} workflowId 
     * @param {string} [roleName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public deleteBucketWorkflowTransition(bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any) {
        return UiFacingApiFp(this.configuration).deleteBucketWorkflowTransition(bucketName, instanceId, accountId, workflowId, roleName, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a bucket expiration workflow
     * @param {string} bucketName 
     * @param {string} instanceId 
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public deleteConfigurationOverlayBucketWorkflowExpiration(bucketName: string, instanceId: string, workflowId: string, options?: any) {
        return UiFacingApiFp(this.configuration).deleteConfigurationOverlayBucketWorkflowExpiration(bucketName, instanceId, workflowId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a bucket transition workflow
     * @param {string} bucketName 
     * @param {string} instanceId 
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public deleteConfigurationOverlayBucketWorkflowTransition(bucketName: string, instanceId: string, workflowId: string, options?: any) {
        return UiFacingApiFp(this.configuration).deleteConfigurationOverlayBucketWorkflowTransition(bucketName, instanceId, workflowId, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an endpoint definition
     * @param {string} hostname 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public deleteConfigurationOverlayEndpoint(hostname: string, uuid: string, options?: any) {
        return UiFacingApiFp(this.configuration).deleteConfigurationOverlayEndpoint(hostname, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes location configuration item
     * @param {string} locationName 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public deleteConfigurationOverlayLocation(locationName: string, uuid: string, options?: any) {
        return UiFacingApiFp(this.configuration).deleteConfigurationOverlayLocation(locationName, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a replication stream
     * @param {string} streamId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public deleteConfigurationOverlayReplicationStream(streamId: string, uuid: string, options?: any) {
        return UiFacingApiFp(this.configuration).deleteConfigurationOverlayReplicationStream(streamId, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a user
     * @param {string} uuid 
     * @param {string} [accessKey] 
     * @param {string} [accountName] 
     * @param {string} [roleName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public deleteConfigurationOverlayUser(uuid: string, accessKey?: string, accountName?: string, roleName?: string, options?: any) {
        return UiFacingApiFp(this.configuration).deleteConfigurationOverlayUser(uuid, accessKey, accountName, roleName, options)(this.fetch, this.basePath);
    }

    /**
     * Generate account access key
     * @param {string} uuid 
     * @param {string} accountName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public generateKeyConfigurationOverlayUser(uuid: string, accountName: string, options?: any) {
        return UiFacingApiFp(this.configuration).generateKeyConfigurationOverlayUser(uuid, accountName, options)(this.fetch, this.basePath);
    }

    /**
     * Get Server-managed configuration values for use by user frontend
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public getConfigurationOverlayView(uuid: string, options?: any) {
        return UiFacingApiFp(this.configuration).getConfigurationOverlayView(uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Get current user's profile
     * @param {string} [xScalRequestUids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public getCurrentUserProfile(xScalRequestUids?: string, options?: any) {
        return UiFacingApiFp(this.configuration).getCurrentUserProfile(xScalRequestUids, options)(this.fetch, this.basePath);
    }

    /**
     * Get instance
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public getInstance(uuid: string, options?: any) {
        return UiFacingApiFp(this.configuration).getInstance(uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Get latest statistics
     * @param {string} uuid 
     * @param {number} [interval] 
     * @param {string} [startTime] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public getInstanceStats(uuid: string, interval?: number, startTime?: string, options?: any) {
        return UiFacingApiFp(this.configuration).getInstanceStats(uuid, interval, startTime, options)(this.fetch, this.basePath);
    }

    /**
     * Get latest instance status snapshot
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public getLatestInstanceStatus(uuid: string, options?: any) {
        return UiFacingApiFp(this.configuration).getLatestInstanceStatus(uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Invite users by email
     * @param {string} userId 
     * @param {Array<any>} invites 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public inviteOrbitUsersByEmail(userId: string, invites: Array<any>, options?: any) {
        return UiFacingApiFp(this.configuration).inviteOrbitUsersByEmail(userId, invites, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new managed Zenko instance
     * @param {string} [instanceName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public provisionHostedInstance(instanceName?: string, options?: any) {
        return UiFacingApiFp(this.configuration).provisionHostedInstance(instanceName, options)(this.fetch, this.basePath);
    }

    /**
     * Regenerate a user's secret key
     * @param {string} accessKey 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public rekeyConfigurationOverlayUser(accessKey: string, uuid: string, options?: any) {
        return UiFacingApiFp(this.configuration).rekeyConfigurationOverlayUser(accessKey, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Performs a search of bucket workflows. Currently returns replication and lifecycle workflows. Filtering ability is limited to all buckets or a list of buckets. 
     * @param {string} accountId 
     * @param {string} instanceId 
     * @param {string} [roleName] 
     * @param {Filters} [filters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public searchWorkflows(accountId: string, instanceId: string, roleName?: string, filters?: Filters, options?: any) {
        return UiFacingApiFp(this.configuration).searchWorkflows(accountId, instanceId, roleName, filters, options)(this.fetch, this.basePath);
    }

    /**
     * Un-claim an instance, deleting it from the user's account
     * @param {string} userId 
     * @param {string} instanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public unclaimInstance(userId: string, instanceId: string, options?: any) {
        return UiFacingApiFp(this.configuration).unclaimInstance(userId, instanceId, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a bucket expiration workflow
     * @param {BucketWorkflowExpirationV1} workflow 
     * @param {string} bucketName 
     * @param {string} instanceId 
     * @param {string} accountId 
     * @param {string} workflowId 
     * @param {string} [roleName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public updateBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any) {
        return UiFacingApiFp(this.configuration).updateBucketWorkflowExpiration(workflow, bucketName, instanceId, accountId, workflowId, roleName, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a bucket replication workflow
     * @param {ReplicationStreamInternalV1} workflow 
     * @param {string} bucketName 
     * @param {string} instanceId 
     * @param {string} accountId 
     * @param {string} workflowId 
     * @param {string} [roleName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public updateBucketWorkflowReplication(workflow: ReplicationStreamInternalV1, bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any) {
        return UiFacingApiFp(this.configuration).updateBucketWorkflowReplication(workflow, bucketName, instanceId, accountId, workflowId, roleName, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a bucket transition workflow
     * @param {BucketWorkflowTransitionV2} workflow 
     * @param {string} bucketName 
     * @param {string} instanceId 
     * @param {string} accountId 
     * @param {string} workflowId 
     * @param {string} [roleName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public updateBucketWorkflowTransition(workflow: BucketWorkflowTransitionV2, bucketName: string, instanceId: string, accountId: string, workflowId: string, roleName?: string, options?: any) {
        return UiFacingApiFp(this.configuration).updateBucketWorkflowTransition(workflow, bucketName, instanceId, accountId, workflowId, roleName, options)(this.fetch, this.basePath);
    }

    /**
     * updates a bucket expiration workflow
     * @param {BucketWorkflowExpirationV1} workflow 
     * @param {string} bucketName 
     * @param {string} instanceId 
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public updateConfigurationOverlayBucketWorkflowExpiration(workflow: BucketWorkflowExpirationV1, bucketName: string, instanceId: string, workflowId: string, options?: any) {
        return UiFacingApiFp(this.configuration).updateConfigurationOverlayBucketWorkflowExpiration(workflow, bucketName, instanceId, workflowId, options)(this.fetch, this.basePath);
    }

    /**
     * updates a bucket transition workflow
     * @param {BucketWorkflowTransitionV1} workflow 
     * @param {string} bucketName 
     * @param {string} instanceId 
     * @param {string} workflowId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public updateConfigurationOverlayBucketWorkflowTransition(workflow: BucketWorkflowTransitionV1, bucketName: string, instanceId: string, workflowId: string, options?: any) {
        return UiFacingApiFp(this.configuration).updateConfigurationOverlayBucketWorkflowTransition(workflow, bucketName, instanceId, workflowId, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a location configuration item
     * @param {string} locationName 
     * @param {string} uuid 
     * @param {LocationV1} location 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public updateConfigurationOverlayLocation(locationName: string, uuid: string, location: LocationV1, options?: any) {
        return UiFacingApiFp(this.configuration).updateConfigurationOverlayLocation(locationName, uuid, location, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a replication stream
     * @param {string} streamId 
     * @param {ReplicationStreamInternalV1} replicationStream 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UiFacingApi
     */
    public updateConfigurationOverlayReplicationStream(streamId: string, replicationStream: ReplicationStreamInternalV1, uuid: string, options?: any) {
        return UiFacingApiFp(this.configuration).updateConfigurationOverlayReplicationStream(streamId, replicationStream, uuid, options)(this.fetch, this.basePath);
    }

}

